/******************************************************************************  Copyright Statement:*  --------------------*  This software is protected by Copyright and the information contained*  herein is confidential. The software may not be copied and the information*  contained herein may not be used or disclosed except with the written*  permission of Quectel Co., Ltd. 2013******************************************************************************//***************************************************************************** * * Filename: * --------- *   example_transpass.c * * Project: * -------- *   OpenCPU * * Description: * ------------ *   This example gives an example for transpass setting. *   Through Uart port, input the special command, there will be given the response *   about transpass operation. * * Usage: * ------ *   Compile & Run: * *     Set "C_PREDEF=-D __EXAMPLE_TRANSPASS__" in gcc_makefile file. And compile the  *     app using "make clean/new". *     Download image bin to module to run. *  *   Operation: *             *     Send data from any port that will transmit the data to modem,and the response *     will be print out from debug port. * * Author: * ------- * ------- * *============================================================================ *             HISTORY *---------------------------------------------------------------------------- *  ****************************************************************************/#ifdef __Pooja_Power_V_0.0.1     //multi slave code#include "custom_feature_def.h"#include "ql_type.h"#include "ql_stdlib.h"     #include "ql_trace.h"#include "ql_timer.h"#include "ql_uart.h"#include "ql_error.h"#include "ql_gprs.h"#include "ql_fs.h"#include "ril.h"#include "ril_network.h"#include "ril_http.h"#include "ril_sms.h"#include "string.h"#include "ql_system.h"#include "fota_main.h"#include "ril_telephony.h"#include "ril_system.h"#include "ril_util.h"#include "ril_location.h"#include "ql_socket.h"#include "ql_wtd.h"#include "ql_time.h"#include "ql_common.h"#include "ril_mqtt.h"#define DEBUG_ENABLE 1#if DEBUG_ENABLE > 0#define DEBUG_PORT  UART_PORT1#define DBG_BUF_LEN   4096static char DBG_BUFFER[DBG_BUF_LEN];#define APP_DEBUG(FORMAT,...) {\    Ql_memset(DBG_BUFFER, 0, DBG_BUF_LEN);\    Ql_sprintf(DBG_BUFFER,FORMAT,##__VA_ARGS__); \    if (UART_PORT2 == (DEBUG_PORT)) \    {\        Ql_Debug_Trace(DBG_BUFFER);\    } else {\        Ql_UART_Write((Enum_SerialPort)(DEBUG_PORT), (u8*)(DBG_BUFFER), Ql_strlen((const char *)(DBG_BUFFER)));\    }\}#else#define APP_DEBUG(FORMAT,...) #endif/********************************************************************************************************************************************************/#define APN_USERID      ""#define APN_PASSWD      ""//#define APP_BIN_URL   "http://1.22.124.222:81/fota/KCPL_V03/KCPL_FOTA_APP.bin"//#define APP_BIN_URL   "http://59.163.219.178:81/fota/CLIMAVENETA_P02/CLIMAVENETA_P02_FOTA_APP.bin" #define HTTP_REQUEST  1  // 0=http-get, 1=http-post, 2=http-file#define TIMEOUT_COUNT 1#define max 40#define  PATH_ROOT   ((u8 *)"myroot")#define LENGTH 100#define URL_LEN 512#define READ_BUF_LEN 1024#define CON_SMS_BUF_MAX_CNT   (1)#define CON_SMS_SEG_MAX_CHAR  (160)#define CON_SMS_SEG_MAX_BYTE  (4 * CON_SMS_SEG_MAX_CHAR)#define CON_SMS_MAX_SEG       (7)#define  SOC_RECV_BUFFER_LEN  1460#define LOGIC_WTD1_TMR_ID  (110 + 1)#define LOGIC_WTD2_TMR_ID  (110 + 2)#define LOGIC_WTD3_TMR_ID  (110 + 3)#define TIMER_ID_WATCHDOG_FEED		TIMER_ID_USER_START+1#define Stack_timer  				TIMER_ID_USER_START+2#define GP_timer 	 				TIMER_ID_USER_START+3#define Stack_timer2 				TIMER_ID_USER_START+4#define Stack_timer3 				TIMER_ID_USER_START+5#define Stack_timer4 				TIMER_ID_USER_START+6#define LOGBOOK_TIMER 				TIMER_ID_USER_START+7#define Fota_Reset_Timer 			TIMER_ID_USER_START+8#define MQTT_TIMER_ID		 		TIMER_ID_USER_START+9#define MAX_TASK_NUM                    11#define MSG_ID_USER_DATA                MSG_ID_USER_START+0x100#define MSG_ID_UART_AND_TIMER_INIT      MSG_ID_USER_START+0x101#define MSG_ID_FOTA_DINIT_CONF          MSG_ID_USER_START+0x102#define SUBTASK1_INITIALIZE             MSG_ID_USER_START+0x103/****************************************************************** Server Param******************************************************************/#define SRVADDR_BUFFER_LEN    100//#define HOST_NAME             "yourproductkey.iot-as-mqtt.cn-shanghai.aliyuncs.com"//#define HOST_NAME             "mqtt.westus3.cloudapp.azure.com"//#define HOST_PORT             1883//#define HOST_NAME             "kmqtt.centralindia.azurecontainer.io"// #define HOST_NAME             "lenzmqtt.tor-iot.com"#define HOST_NAME              "Iemqtt.tor-iot.com"#define HOST_PORT              1883//#define HOST_NAME             "broker.mqttdashboard.com"//#define HOST_PORT             1883/******************************************************************  MQTT Param******************************************************************/MQTT_Urc_Param_t*	  mqtt_urc_param_ptr = NULL;ST_MQTT_topic_info_t  mqtt_topic_info_t, Sub_Topic_Set;bool DISC_flag  = TRUE;bool CLOSE_flag = TRUE;/******************************************************************  Sample Param******************************************************************/Enum_ConnectID connect_id = ConnectID_0;u32 pub_message_id = 0; u32 sub_message_id = 0;    u8 product_key[] =   "your-productkey\0";   //<ali cloud needs it.    u8 device_name[]=    "your-devicename\0";   //<ali cloud needs it.u8 device_secret[] = "your-devicesecret\0"; //<ali cloud needs it.//u8 clientID[] =      "\0";//u8 clientID[] =      "your-clientID\0";u8 username[] =      "\0";u8 passwd[] =        "\0";//u8 username[] =      "admin\0";//u8 username[] =      "emqx\0";//u8 passwd[] =        "public\0";//static u8 test_data[128] =  "hello cloud\0"; //<first packet data//static u8 test_topic[128] = "KTL\0"; //<topicstatic u8 test_data[128] =  "hello World\0"; //<first packet data//static u8 test_topic[128] = "KTL\0"; //<topicstatic u8 test_topic[128] = "TorLenz/MQTT_v1/Payload1\0"; //<topic// MAX TOPIC CAN SUB '9'u8 NO_OF_SUB_TOPIC = 1;                    u8 *test_topic_SUB_array[]={						//"LENZ/MQTT_v1/Config\0" //TOPIC1						"PUJAPOWER/MQTT_v1/Config\0" 						//TOPIC3					   };u8 *test_topic_PUB_array[]={							// "LENZ/MQTT_v1/MultiSlave\0" //TOPIC2							"PUJAPOWER/MQTT_v1/Payload\0" 							};		u8 *test_topic_BUF_array[]={							"LENZ/MQTT_v1/Buffer\0"													   };char HTTP_POST_MSG[3000];  /**************************************************************************************************//* DEVICE URL SETTING *//**************************************************************************************************/// FOTA URLu8 APP_BIN_URL[1024] = "http://59.163.219.178:81/fota/Electromech_P01/Electromech_P01_FOTA_APP.bin";/**************************************************************************************************///SERVER URL //u8 HTTP_URL_ADDR[1024] = "http://electronicaapi.remotemonitor.in/api/values/PostStringData\0";//u8 HTTP_URL_ADDR[1024] = "http://electronicaapi.remotemonitor.in/api/values/PostsStringData\0";//u8 HTTP_URL_ADDR[1024] = "https://emote.emech.in/api/PostEMotePL\0";//#define HTTP_URL_ADDR   "http://gencsr.kangitentpl.com/datasar-csr/api/gprs/pushp\0" //u8 HTTP_URL_ADDR[1024] = "http://pocapitest.kloudqapps.net/api/values/PostStringData\0";   //u8 HTTP_URL_ADDR[1024] = "http://emote.emech.in:8080/api/PostEMotePL\0";//u8 HTTP_URL_ADDR[1024] = "https://emote.emech.in/api/PostEmotePLVFDIOBox\0";// u8 HTTP_URL_ADDR[1024] = "http://emote.emech.in:8080/api/PostEmotePLVFDIOBox\0";/**************************************************************************************************//* DEVICE PARAMETERS SETTING *//**************************************************************************************************/u8 SERVER_PROTOCOL_SELECTION = 1;   // HTTP --> 1, TCP/IP --> 2u8 APN_NAME[25] = "airteliot.com\0";            u8 DEVICE_ID[15]="30240012\0"; //50480011// u8 START_OF_DEVICE_ID[4] = "50\0";u8 VERSION[25]="Pooja_Power Ver 0.0.3\0"; //u8 MODEL_NAME[30]= "EMS\0";u8 MODEL_NAME[30]= "Pooja Power\0"; u8 UTC_DATE_TIME[20] = "00000000000000\0";u8 UTC_DATE_TIME_1[20] = "00000000000000\0";u8 UTC_DATE_TIME_2[20] = "00000000000000\0";u8 UTC_DATE_TIME_3[20] = "00000000000000\0";u8 UTC_DATE_TIME_4[20] = "00000000000000\0";u8 UTC_DATE_TIME_5[20] = "00000000000000\0";  /**************************************************************************************************/u8 ST_Interval_1[6] = "00:03\0";  //u32 ST_Interval =  30000;        //convert time buffer to seconds valueu32 ST_Interval =  30000;        //convert time buffer to seconds value     data sending frequency/**************************************************************************************************//**************************************************************************************************///ST_Time time;Enum_PinName  WATCHDOG_FEED_PIN = PINNAME_CTS; //Enum_PinName  MODBUS_PATH_SELECTION_PIN = PINNAME_RXD_AUX;ST_Time time;typedef enum {	NORMAL_DATA=0,    ERROR_DATA=1,	NO_COMM_DATA=2}DATA_Type_enum;typedef enum {	CREATE_CONNECTION_PACKET=0,    DATA_PACKET=1,	NO_COMM_WITH_CONTROLLER_PACKET=2,	VALID_DATA_RCV_FROM_SERVER_PACKET=3}SERVER_Packet_enum;typedef enum{    STATE_NW_QUERY_STATE,    STATE_MQTT_CFG,    STATE_MQTT_OPEN,    STATE_MQTT_CONN,    STATE_MQTT_SUB,    STATE_MQTT_PUB,    STATE_MQTT_TUNS,    STATE_MQTT_CLOSE,    STATE_MQTT_DISC,    STATE_MQTT_TOTAL_NUM}Enum_ONENETSTATE;static u8 m_mqtt_state = STATE_NW_QUERY_STATE;typedef struct{    u8 aData[CON_SMS_SEG_MAX_BYTE];    u16 uLen;} ConSMSSegStruct;typedef struct{    u16 uMsgRef;    u8 uMsgTot;    ConSMSSegStruct asSeg[CON_SMS_MAX_SEG];    bool abSegValid[CON_SMS_MAX_SEG];} ConSMSStruct;typedef struct {	u8 MOBILE_NO[RIL_SMS_PHONE_NUMBER_MAX_LEN];	u8 TRIGGER_STATUS;	u8 SUCCESS_STATUS;}FOTA_STATUS;ConSMSStruct g_asConSMSBuf[CON_SMS_BUF_MAX_CNT];FOTA_STATUS FOTA_STATUS_VARIABLE;static ST_GprsConfig m_GprsConfig = {    "",  		// APN name    "",         // User name for APN    "",         // Password for APN    0,    NULL,    NULL,};ST_UARTDCB port2_dcb;s32 WTD_Id, WTD_Id2;s32 pdpCntxtId;static Enum_SerialPort m_myVirtualPort = VIRTUAL_PORT2;static u8 m_Read_Buffer[1024];static u8 m_Read_Buffer_fota[1024] = "http://1.22.124.222:81/fota/Chiller_1/Chiller_1_FOTA_APP.bin";/************************************************************************//* Definition for Server IP Address and Socket Port Number              *//************************************************************************/static u8  m_SrvADDR[20] ="219.65.92.105\0";static u32 m_SrvPort = 6556; static u8  m_SrvADDR_1[20] ="219.65.92.105\0";static u32 m_SrvPort_1 = 6556;u8 m_SrvPort1[5] = {0};u8 m_SrvPort12[5] = {0};u8 ST_Interval_12[6] = "00:30\0";  //u8 ST_Interval_12[6] = "00:30\0"; u32 ST_Interval_2 = 300;      //Modbus query delayu32 ST_Interval_3 = 2000;     //GPRS Time out periodu32 ST_Interval_4 = 2000;     //MODBUS Query WRITE period.u32 LOGBOOK_Interval = 900*1000;u32 ST_Interval_6 = 120*1000;u32 Timer_Val_WatchdogFeed = 500;static u32 GPT_Interval =15000;//static u32 GPT_Interval =20000;   //system and alarm data check timer error time. In each 10 sec MQTT timer configuring after every 0.5sec                                 //0.5*40=20sec . configuring 20 times. u32 MQTT_TIMER_PERIOD = 2000;   //configuring after every 2 secint ID_FLAG = 0; static s32 m_param1 = 0;  static s32 m_param2 = 0;static s32 m_param3 = 0;static s32 m_param4 = 0;static s32 m_param5 = 0;static s32 m_param6 = 0;static s32 m_param7 = 0;static s32 m_param8 = 0;  u8 strBuf_url[LENGTH] = {0};u8 strBuf_ser_mod[LENGTH] = {0};u8 strBuf_data[2000] = {0};              // mention the size of buffer to avoid variable corruptionu8 strBuf_id[LENGTH] = {0};u8 strBuf_apn[LENGTH] = {0};u8 strBuf_ip[LENGTH] = {0};u8 strBuf_port[LENGTH] = {0};u8 strBuf_time[LENGTH] = {0};u8 strBuf_time1[LENGTH] = {0};u8 strBuf_time_store[LENGTH] = {0};u8 strBuf_Count[LENGTH] = {0};int Slave_1=0, Slave_2=0, Slave_3=0, Slave_4=0;  // made by cpu16 meter_no;  // made by cpint Total_No_Of_Queries=0; // made by cpint i=0;                     //made by cpint count=0;   //made by cpint Flag=0;int Slave_1_QN=0, Slave_2_QN=0, Slave_3_QN=0, Slave_4_QN=0;u8 filePath1[LENGTH] = {0};u8 filePath2[LENGTH] = {0};u8 filePath3[LENGTH] = {0};u8 filePath4[LENGTH] = {0};u8 filePath5[LENGTH] = {0};u8 filePath6[LENGTH] = {0};u8 filePath7[LENGTH] = {0};u8 filePath8[LENGTH] = {0};u8 filePath9[LENGTH] = {0};u8 filePath10[LENGTH] = {0};u8 filePath11[LENGTH] = {0};u8 filePath12[LENGTH] = {0};u8 filePath13[LENGTH] = {0};u8 filePath14[LENGTH] = {0};   u8 filePath15[1024] = {0};   // made by cpu8 filePath16[1024] = {0};   // made by cpu8 filePath17[1024] = {0};   // made by cpu8 filePath18[1024] = {0};   // made by cp/************************************************************************//* Definition for GPRS PDP context                                      *//************************************************************************/static s32 m_GprsActState    = 0;   // GPRS PDP activation state, 0= not activated, 1=activatedstatic s32 m_SocketId        = -1;  // Store socket Id that returned by Ql_SOC_Create()bool m_SocketConnState = 0;   // Socket connection state, 0= disconnected, 1=connectedstatic u8  m_SocketRcvBuf[SOC_RECV_BUFFER_LEN];static u8 m_URL_Buffer[URL_LEN];u8 COUNT_FOR_STORE_TIME_IN_UFL = 0;u8 arrHttpRcvBuf[10*1024]; // 10K buffer for http datachar NETWORK_STATUS_INDICATOR = 0;char DATA_FROM_CONTROLLER[1000]={0};char DATA_FROM_CONTROLLER_2[1000]={0};char DATA_FROM_CONTROLLER_3[1000]={0};char DATA_FROM_CONTROLLER_4[1000]={0};char DATA_FROM_CONTROLLER_5[1000]={0};char DATA_STRING_COUNTER=0;char QUERY_SEND_STAGE = 0 ,QUERY_RCV_STAGE=0, module_state = 0;char ERROR_STATUS_1=0, ERROR_STATUS_2=0, ERROR_STATUS_3=0, ERROR_STATUS_4=0, ERROR_STATUS_5=0, ERROR_STATUS_6=0, ERROR_STATUS_7=0, ERROR_STATUS_8=0, ERROR_STATUS_9=0, ERROR_STATUS_10=0, ERROR_STATUS_11=0, ERROR_STATUS_12=0;char MODBUS_WRITE_QURIES_COUNT=0,database[900]={0};int address_mod[84], data_mod[84];char NO_COMM_WITH_CONTROLLER_COUNT = 0;u16 NO_OF_MODBUS_VARIABLE_COUNT = 0;u16 STORE_DATA_COUNT = 0, STORE_DATA_LENGTH = 0;s32 wtdid2,wtdid1;static int s_iPassTask=1;float DEVICE_LATITUDE=0.0, DEVICE_LONGITUDE=0.0;//MODBUS PARAMETER DECLARATION/*----------------------------------------*/char MODBUS_SLAVE_ID = 0x01;char MODBUS_SLAVE_ID_BUFF[100];char MOD_SLAVE[4] = {0,0,0,0};//char MODBUS_SLAVE[1] = '\0';//char MODBUS_SLAVE[2] = '\0';//char MODBUS_SLAVE[3] = '\0';char FUNCTION_CODE[100];int  MODBUS_ADDRESS[100];int  MODBUS_LEGTH[100];/*----------------------------------------*/char NO_OF_QUERY;char Temp_Queries;char QUERY_POINTER = 0;char QUERY_RCV_POINTER = 0;char QUERY_REPEAT_COUNTER=0;char QUERY_REPEAT_COUNT = 2;char TIMESTAMP_SUB_MSG[16] = "00000000000000\0";bool HTTP_BLOCK_STATE_FLAG = 0;bool HTTP_RESPONSE_FLAG = 0;bool socket_flag = 1,reset_flag = 1, send_flag1 = 0, send_flag2=0; //for uart operationbool start_flag = 1, string_flag = 0, fota_flag=0;bool storage_flag = 0 , send_data_flag = 0;bool send_1 = 0,MODBUS_WRITE_FLAG = 0, SEND_DATA_TO_SERVER_FLAG = 0;bool PORT2_COMMUNICATION_FLAG=0, ERROR_FLAG=0, comm_flag = 0, GPRS_flag = 0, GSM_flag = 0, NO_COMMUNICATION_WITH_CONTROLLER_INDICATION = 0;bool DATA_SEND_TO_SERVER_FLAG = 0;bool GPRS_Connection_Flag = 0;bool SOCKET_IN_WOULD_BLOCK_FLAG = 0;bool SERVER2_SETTING_SELECTION_FLAG=0;bool SYSTEM_INITIALIZE_WATCHDOG_FLAG = 1, SYSTEM_WATCHDOG_FLAG=1;  // watchdog flagsbool LOGBOOK_DATA_FLAG = 1;bool COMMUNICATION_WITH_CONTROLLER_FLAG = 1;bool DATA_RCV_ON_UART_FOR_MODBUS_FLAG = 0;bool HTTP_GPRS_SETTING_FLAG = 0;bool MODBUS_STORE_PARAMETER_DETECTECTION_FLAG = 0;bool DATA_STORE_FLAG = 0;bool Network_Time_Set_Flag = 0;bool INITIAL_RTC_TIME_SYNC_FLAG = 0;bool CHECK_MODBUS_QUERY_RESPONSE_FLAG = 0;//USER DEFINED APIsvoid CREATE_AND_STORE_MODBUS_DATA(char PACKET_TYPE);void SEND_STORE_DATA();void GET_Present_Time();void STORE_TIME_TO_MEMORY();s32 Sync_NetworkTime();static s32 ATResponse_Sync_NetworkTime_handler(char* line, u32 len, void* userdata);void Set_LocalTime(u8 *str);u32 HEX_TO_INTEGER(char Hex_Value_1, char Hex_Value_2);int PORT_VALUE_CAL(char port_buf[]);u32 CONVERT_TIME_BUFFER_TO_SECONDS_VALUE(char interval_buf[]);void READ_DATA_FROM_UFS(int val_mem);void WRITE_DATA_TO_UFS(int val_mem1, char writeBuffer[]);void SEND_SMS(int val_mem1, char writeBuffer[],char phno[]);void SEPARATE_MODBUS_DATA(char No_Of_Data, char write_mod[]);void CALCULATE_CRC(int address_1, int data_1);void MODBUS_RESPONSE_CHECK(char *data,int length);void TIMER_INIITIALIZE();char DECIMAL_TO_HEX(unsigned n);static void DELAY(int time_delay);static void TIMER_HANDLER(u32 timerId, void* param);static void TIMER_HANDLER_SUBTASK1(u32 timerId, void* param);void WTD_Init();void WTD_DeInit();void CREATE_AND_SEND_MODBUS_DATA(char Device_ID, char Function_Code, int Modbus_Address, int Data_To_Write_Or_Lenght);void SET_MODBUS_PARAMETER();void CAPTURE_DATA_FOR_PAYLOAD(char *Data_Buf, int Lenght_Param, char Data_Type);float HEX_TO_FLOAT(unsigned char Value_3 ,unsigned char Value_4,unsigned char Value_1,unsigned char Value_2);void PAYLOAD_FORMATION_FOR_SENDING(char PACKET_TYPE);void DEVICE_PARAMETER_CONFIGURATION(char *Data_From_Sub_Topic);void SET_SUB_TOPIC_DETAILS();bool COMPARE_TIMESTAMP_FOR_SUB_MSG(char *Rcv_Time_Stamp,char *Store_Time_Stamp);//SYSTEM GIVEN USER MODIFIED APIsstatic void Callback_UART_Hdlr_Main_Port(Enum_SerialPort port, Enum_UARTEventType msg, bool level, void* customizedPara);static void Callback_UART_Hdlr_Modbus_Port(Enum_SerialPort port, Enum_UARTEventType msg, bool level, void* customizedPara);static void Callback_UART_Hdlr_ETHERNET_PORT(Enum_SerialPort port, Enum_UARTEventType msg, bool level, void* customizedPara);static void Location_Program(void);static void Callback_Location(s32 result,ST_LocInfo* loc_info);//SYSTEMS APIsvoid SendEvent2AllSubTask(u32 msgId,u32 iData1, u32 iData2);static void HTTP_Program(u8 http_action, char Data_Packet_Send_To_Server[]);static void SIM_Card_State_Ind(u32 sim_stat);static void Hdlr_RecvNewSMS(u32 nIndex, bool bAutoReply);static bool SMS_Initialize(void);static bool ConSMSBuf_IsIntact(ConSMSStruct *pCSBuf,u8 uCSMaxCnt,u8 uIdx,ST_RIL_SMS_Con *pCon);static bool ConSMSBuf_AddSeg(ConSMSStruct *pCSBuf,u8 uCSMaxCnt,u8 uIdx,ST_RIL_SMS_Con *pCon,u8 *pData,u16 uLen);static s8 ConSMSBuf_GetIndex(ConSMSStruct *pCSBuf,u8 uCSMaxCnt,ST_RIL_SMS_Con *pCon);static bool ConSMSBuf_ResetCtx(ConSMSStruct *pCSBuf,u8 uCSMaxCnt,u8 uIdx);static void callback_onTimer(u32 timerId, void* param);/************************************************************************//* Declarations for GPRS and TCP socket callback                        *//************************************************************************///// This callback function is invoked when GPRS drops down.static void Callback_GPRS_Deactived(u8 contextId, s32 errCode, void* customParam );static void Callback_GPRS_Actived(u8 contexId, s32 errCode, void* customParam);// This callback function is invoked when the socket connection is disconnected by server or network.static void Callback_Socket_Close(s32 socketId, s32 errCode, void* customParam );//// This callback function is invoked when socket data arrives.static void Callback_Socket_Read(s32 socketId, s32 errCode, void* customParam );//// This callback function is invoked in the following case:// The return value is less than the data length to send when calling Ql_SOC_Send(), which indicates// the socket buffer is full. Application should stop sending socket data till this callback function// is invoked, which indicates application can continue to send data to socket.static void Callback_Socket_Write(s32 socketId, s32 errCode, void* customParam );static void SOC_CONNECT_TO_SERVER();static void GPRS_TCP_Program(char PACKET_TYPE);/****************************************************************** MQTT recv callback function******************************************************************/static void mqtt_recv(u8* buffer,u32 length);/******************************************************************/ void proc_main_task(){    ST_MSG msg;    bool keepGoing = TRUE;    s32 ret;   	u32 i=0, j=0;	u8 temp_ch;	s32 handle = -1;	u32 readenLen = 0;	s32 iResult = 0;	s64  space = 0;		u32 writenLen = 0;     s32 wtdid;	SYSTEM_INITIALIZE_WATCHDOG_FLAG = 0 ;	/*----------------------------------------------------------*/	/*----- SERIAL SETTING OF MODBUS PROTOCOL PORT -------------*/    	port2_dcb.baudrate = 19200;  //	port2_dcb.baudrate = 19200; 	port2_dcb.dataBits = DB_8BIT;	port2_dcb.stopBits = SB_ONE;	port2_dcb.parity   = PB_EVEN;	port2_dcb.flowCtrl = FC_NONE;	/*----------------------------------------------------------*/	    Ql_UART_Register(UART_PORT1, Callback_UART_Hdlr_Main_Port, NULL);    Ql_UART_Open(UART_PORT1, 115200, FC_NONE);    //Ql_UART_Register(UART_PORT2, Callback_UART_Hdlr_Modbus_Port, NULL);    //Ql_UART_Open(UART_PORT2, 19200, FC_NONE);	Ql_UART_Register(UART_PORT3, Callback_UART_Hdlr_Main_Port, NULL);    //Ql_UART_Open(UART_PORT3, 115200, FC_NONE);        APP_DEBUG("\r\n<--OpenCPU: transpass test!%s -->\r\n",MODEL_NAME);  	Ql_Debug_Trace("\r\n<--OpenCPU: transpass test!%s VERSION: %s-->\r\n",MODEL_NAME, VERSION);    // Register & open Modem port    //Ql_UART_Register(m_myVirtualPort, Callback_UART_Hdlr_Main_Port, NULL);    //Ql_UART_Open(m_myVirtualPort, 0, 0);		//Ql_GPIO_Init(MODBUS_PATH_SELECTION_PIN, PINDIRECTION_OUT, PINLEVEL_HIGH, PINPULLSEL_PULLUP);	//Ql_GPIO_SetLevel(MODBUS_PATH_SELECTION_PIN, PINLEVEL_HIGH);		Enum_FSStorage storage = Ql_FS_UFS;    APP_DEBUG("\r\n<-- Reading UFS....-->\r\n\r\n");	module_state =1;//	APP_DEBUG("<-- MODULE STATE => %d \r\n", module_state);  		space  = Ql_FS_GetFreeSpace(storage); //   APP_DEBUG("<-- FreeSpace = %lld\r\n",space);         //check total space    space = Ql_FS_GetTotalSpace(storage);                //    APP_DEBUG("<-- TotalSpace = %lld\r\n",space);		ret = Ql_FS_CheckDir(PATH_ROOT);    if(ret != QL_RET_OK)    {		APP_DEBUG("<-- Directory(%s) is not existed, creating Directory.... -->\r\n", PATH_ROOT);		ret  = Ql_FS_CreateDir(PATH_ROOT);		if(ret != QL_RET_OK)		{			APP_DEBUG("<-- Creating Directory(%s) failed -->\r\n", PATH_ROOT);			return -1;		}		else		{			APP_DEBUG("<-- Creating Directory(%s) OK! -->\r\n", PATH_ROOT);		}            }/*	else	{		APP_DEBUG("<-- The Alredy present path is :%s -->\r\n", PATH_ROOT);		} */		Ql_memset(FOTA_STATUS_VARIABLE.MOBILE_NO, 0, sizeof(FOTA_STATUS_VARIABLE.MOBILE_NO));	FOTA_STATUS_VARIABLE.TRIGGER_STATUS = 0;	FOTA_STATUS_VARIABLE.SUCCESS_STATUS = 0;	Ql_memset(m_GprsConfig.apnName, 0x0, sizeof(m_GprsConfig.apnName));	//APP_DEBUG("\r\n\n<-- APN BEFORE = %s\r\n", m_GprsConfig.apnName);  	Ql_memcpy(m_GprsConfig.apnName, APN_NAME, Ql_strlen(APN_NAME));//	APP_DEBUG("<-- APN Used is %s -->\r\n\n", m_GprsConfig.apnName);   	//APP_DEBUG("<----------------------------------------------------\n");	//APP_DEBUG("<----------------------------------------------------\n");	READ_DATA_FROM_UFS(1);	READ_DATA_FROM_UFS(2); // READ_DATA_FROM_UFS(3);	READ_DATA_FROM_UFS(4);	READ_DATA_FROM_UFS(5);	READ_DATA_FROM_UFS(6);	READ_DATA_FROM_UFS(7);	READ_DATA_FROM_UFS(8);	READ_DATA_FROM_UFS(9);	READ_DATA_FROM_UFS(10);	READ_DATA_FROM_UFS(11);	READ_DATA_FROM_UFS(12);	READ_DATA_FROM_UFS(13);	READ_DATA_FROM_UFS(14);	READ_DATA_FROM_UFS(15);	READ_DATA_FROM_UFS(16);	READ_DATA_FROM_UFS(17);	READ_DATA_FROM_UFS(18);	//APP_DEBUG("<----------------------------------------------------\n");	//APP_DEBUG("<----------------------------------------------------\n");		// memset(clientID, 0x0, sizeof(clientID));	// Ql_memcpy(clientID, DEVICE_ID, Ql_strlen(DEVICE_ID));	// APP_DEBUG("\r\n<-- Client id is %s -->\r\n", clientID);		module_state =2;	//APP_DEBUG("\r\n<-- MODULE STATE => %d \r\n", module_state);		// ret = Ql_OS_SendMessage(subtask1_id,MSG_ID_UART_AND_TIMER_INIT,1, 0);	// if(ret <0)	// {		// APP_DEBUG("\r\n<--failed!!, Ql_OS_SendMessage(1, %d, %d) fail,  ret=%d-->\r\n", 1, 0, ret);	// }	// APP_DEBUG("\r\n<--Ql_OS_SendMessage(%d, %d, %d) ret=%d-->\r\n",MSG_ID_UART_AND_TIMER_INIT,1, 0, ret);	//Ql_UART_OpenEx(UART_PORT2, &port2_dcb);	// Ql_Debug_Trace("\r\n<--OpenCPU: transpass test!%s VERSION: %s-->\r\n",MODEL_NAME, VERSION);	//check total space    space  = Ql_FS_GetFreeSpace(storage); //   APP_DEBUG("\r\n<-- FreeSpace=%lld -->\r\n",space);	WTD_Init();		TIMER_INIITIALIZE();		//	APP_DEBUG("\r\n<-- Modbus is not configured -->\r\n\r\n");	SET_MODBUS_PARAMETER();		ret = Ql_Timer_Start(GP_timer,GPT_Interval,TRUE);	if(ret < 0)	{		APP_DEBUG("\r\n<--failed!! GP-timer Ql_Timer_Start fail, ret=%d-->\r\n",ret);	}                	ret = Ql_Mqtt_Recv_Register(mqtt_recv);	// MQTT Define RCV Function of SUB		send_flag2 = 1;	send_flag1 = 0;	QUERY_SEND_STAGE = 0;    while (keepGoing)    {		Ql_OS_GetMessage(&msg);        switch(msg.message)        {            case MSG_ID_RIL_READY:                 APP_DEBUG("<-- Open CPU RIL is ready -->\r\n");                Ql_RIL_Initialize();            case MSG_ID_URC_INDICATION:                switch (msg.param1)                {                    case URC_SYS_INIT_STATE_IND:                    {					//	APP_DEBUG("<-- Sys Init Status %d -->\r\n", msg.param2);						if (SYS_STATE_SMSOK == msg.param2)						{							APP_DEBUG("<-- SMS module is ready -->\r\n");						//	APP_DEBUG("<-- Initialize SMS-related options -->\r\n");							iResult = SMS_Initialize();         							if (!iResult)							{								APP_DEBUG("Fail to initialize SMS\r\n");							}							else							{								if(FOTA_STATUS_VARIABLE.TRIGGER_STATUS == 0)								{								//	APP_DEBUG("<-- FOTA TRIGGER NOT DETECTED\r\n");								}								else								{									if(FOTA_STATUS_VARIABLE.SUCCESS_STATUS == 0)									{										APP_DEBUG("<-- FOTA SUCCESS STATUS IS ZERO\r\n");										SEND_SMS(1,"FOTA FAILED\0",FOTA_STATUS_VARIABLE.MOBILE_NO);									}									else									{										APP_DEBUG("<-- FOTA SUCCESS STATUS IS ZERO\r\n");										SEND_SMS(1,"FOTA DONE\0",FOTA_STATUS_VARIABLE.MOBILE_NO);									}									WRITE_DATA_TO_UFS(12,",,\0");								}							}						}						break;								    case URC_MQTT_OPEN:						{							mqtt_urc_param_ptr = msg.param2;							if(0 == mqtt_urc_param_ptr->result)							{								APP_DEBUG("<-- MQTT client opened successfully -->\r\n");								m_mqtt_state = STATE_MQTT_CONN;							}							else							{								APP_DEBUG("<-- <Open a MQTT client failure,error = %d -->\r\n",mqtt_urc_param_ptr->result);							}						}						break;					case URC_MQTT_CONN:						{							mqtt_urc_param_ptr = msg.param2;							if(0 == mqtt_urc_param_ptr->result)							{								APP_DEBUG("<-- MQTT server connected successfully -->\r\n");								m_mqtt_state = STATE_MQTT_SUB;							}							else							{								APP_DEBUG("//<Connect to MQTT server failure,error = %d\r\n",mqtt_urc_param_ptr->result);							}						}						break;					case URC_MQTT_SUB:						{							mqtt_urc_param_ptr = msg.param2;							if((0 == mqtt_urc_param_ptr->result)&&(128 != mqtt_urc_param_ptr->sub_value[0]))							{								APP_DEBUG("<-- Subscribe topics successfully -->\r\n");								m_mqtt_state = STATE_MQTT_PUB;							}							else							{								APP_DEBUG("<-- Subscribe topics failure,error = %d\r\n -->",mqtt_urc_param_ptr->result);							}						//	APP_DEBUG("<-- EXIT CASE SUB\r\n");						}						break;											case URC_MQTT_PUB:						{							mqtt_urc_param_ptr = msg.param2;							if(0 == mqtt_urc_param_ptr->result)							{								APP_DEBUG("<-- Publish messages to MQTT server successfully -->\r\n");								m_mqtt_state = STATE_MQTT_TOTAL_NUM;								SYSTEM_WATCHDOG_FLAG = 1;							}							else							{								APP_DEBUG("//<Publish messages to MQTT server failure,error = %d\r\n",mqtt_urc_param_ptr->result);							}						}						break;					case URC_MQTT_CLOSE:						{							mqtt_urc_param_ptr = msg.param2;							if(0 == mqtt_urc_param_ptr->result)							{								APP_DEBUG("//<Closed MQTT socket successfully\r\n");							}							else							{								APP_DEBUG("//<Closed MQTT socket failure,error = %d\r\n",mqtt_urc_param_ptr->result);							}						}						break;					case URC_MQTT_DISC:						{							mqtt_urc_param_ptr = msg.param2;							if(0 == mqtt_urc_param_ptr->result)							{								APP_DEBUG("//<Disconnect MQTT successfully\r\n");							}							else							{								APP_DEBUG("//<Disconnect MQTT failure,error = %d\r\n",mqtt_urc_param_ptr->result);							}						}						break;					case URC_MQTT_STATE:						{							mqtt_urc_param_ptr = msg.param2;							APP_DEBUG("<-- MQTT state report,connectID:%d,statecode:%d -->\r\n",mqtt_urc_param_ptr->connectid,mqtt_urc_param_ptr->mqtt_state);							}						break;													}					                case URC_CFUN_STATE_IND:                    APP_DEBUG("<-- CFUN Status:%d -->\r\n", msg.param2);                    break;									case URC_NEW_SMS_IND:					{						APP_DEBUG("<-- New SMS Arrives: index=%d\r\n", msg.param2);						Hdlr_RecvNewSMS((msg.param2), FALSE);						break;					}						                case URC_SIM_CARD_STATE_IND:                    SIM_Card_State_Ind(msg.param2);                    break;					                case URC_GSM_NW_STATE_IND:				     					 if(msg.param2==2)					 {						APP_DEBUG("<-- GSM Network Not Registered -->\r\n");					 }					 if(msg.param2==1)					 {						APP_DEBUG("<-- GSM Network Registered -->\r\n");					 }                     //APP_DEBUG("<-- GSM Network Status:%d -->\r\n", msg.param2);					 					if (NW_STAT_REGISTERED == msg.param2 || NW_STAT_REGISTERED_ROAMING == msg.param2)                    {						GSM_flag = 1;					//	APP_DEBUG("\r\n<-- GSM_flag = %d\r\n", GSM_flag);					    APP_DEBUG("<-- GSM_flag On -->\r\n");						if((Network_Time_Set_Flag == 0) && (GPRS_flag == 1))						{							Network_Time_Set_Flag = 1;							Sync_NetworkTime();						}												if(GPRS_flag == 1)						{							NETWORK_STATUS_INDICATOR = 3; 						}						else{NETWORK_STATUS_INDICATOR = 1;}					}					else					{						GSM_flag = 0;						if(GPRS_flag == 1)						{							NETWORK_STATUS_INDICATOR = 2; 						}						else{NETWORK_STATUS_INDICATOR = 0;}					}				//	APP_DEBUG("<-- NETWORK_STATUS_INDICATOR = %d\r\n", NETWORK_STATUS_INDICATOR);                    break;                case URC_GPRS_NW_STATE_IND:                   // APP_DEBUG("<-- GPRS Network Status:%d -->\r\n", msg.param2);				    if(msg.param2==1)					{						APP_DEBUG("<-- GPRS Network Registered -->\r\n");					}					if(msg.param2==2)					{						APP_DEBUG("<-- Searching GPRS Network -->\r\n");					}					if(msg.param2==0)					{						APP_DEBUG("<-- GPRS Network Not Registered -->\r\n");					}                    					if (NW_STAT_REGISTERED == msg.param2 || NW_STAT_REGISTERED_ROAMING == msg.param2)                    {						GPRS_flag = 1;						APP_DEBUG("\r\n<-- GPRS_flag on \r\n");						if((Network_Time_Set_Flag == 0) && (GSM_flag == 1))						{							Network_Time_Set_Flag = 1;							Sync_NetworkTime();						}												SYSTEM_INITIALIZE();						if(GSM_flag == 1)						{							NETWORK_STATUS_INDICATOR = 3; 						}						else{NETWORK_STATUS_INDICATOR = 2;}                    }					else					{						GPRS_flag = 0;						if(GSM_flag == 1)						{							NETWORK_STATUS_INDICATOR = 1; 						}						else{NETWORK_STATUS_INDICATOR = 0;}					}				//	APP_DEBUG("<-- NETWORK_STATUS_INDICATOR = %d\r\n", NETWORK_STATUS_INDICATOR);                    break;                }                break;							case MSG_ID_USER_DATA:				{										if(fota_flag == 0 )					{						s32 totalBytes;												totalBytes = Ql_strlen(HTTP_POST_MSG);												pub_message_id++;  // The range is 0-65535. It will be 0 only when<qos>=0.						ret = RIL_MQTT_QMTPUB(connect_id,pub_message_id,QOS1_AT_LEASET_ONCE,0,test_topic_PUB_array[0],totalBytes,HTTP_POST_MSG);						if (RIL_AT_SUCCESS == ret)						{							APP_DEBUG("<-- The return value is %d -->\r\n",ret);							APP_DEBUG("<-- Publish message command execute successfully -->\r\n");							APP_DEBUG("<-- Publish message is %s -->\r\n",HTTP_POST_MSG);							// if(DATA_STORE_FLAG == 1)							// {								// APP_DEBUG("<-- DATA_STORE_FLAG is On\r\n");									// SEND_STORE_DATA();							// }						}						// else						// {							// APP_DEBUG("<-- Publish a message to server failure -->\r\n");							// DATA_STORE_FLAG = 1;							// STORE_DATA_STRING_TO_MEMORY(HTTP_POST_MSG, STORE_DATA_LENGTH);						// }					}					else{APP_DEBUG("<-- FOTA FLAG IS TRIGGER\r\n");}				} break;							case SUBTASK1_INITIALIZE:													APP_DEBUG("\r\n<-- Receive MSG for SUBTASK 1, SUBTASK 1 Initialize -->\r\n");							if(module_state > 1)							{								ret =  (subtask1_id,MSG_ID_UART_AND_TIMER_INIT,1, 0);								if(ret <0)								{									APP_DEBUG("\r\n<--failed!!, Ql_OS_SendMessage(1, %d, %d) fail,  ret=%d-->\r\n", 1, 0, ret);								}							//	APP_DEBUG("\r\n<--Ql_OS_SendMessage(%d, %d, %d) ret=%d-->\r\n",MSG_ID_UART_AND_TIMER_INIT,1, 0, ret);							}else{APP_DEBUG("<-- MODULE STATE LESS THAN 2=> %d",module_state);}											break;            default:                break;        }       }}/***************************************************************The 1st sub task***************************************************************/void proc_subtask1(s32 TaskId){    bool keepGoing = TRUE;    ST_MSG subtask1_msg;    s32 ret;	Ql_UART_Register(UART_PORT2, Callback_UART_Hdlr_Modbus_Port, NULL);		// port2_dcb.baudrate = 19200;	// port2_dcb.dataBits = DB_8BIT;	// port2_dcb.stopBits = SB_ONE;	// port2_dcb.parity   = PB_NONE;	// port2_dcb.flowCtrl = FC_NONE;		//APP_DEBUG("<----------------------------------------------------\n");//	APP_DEBUG("\r\n<------------------Timer Init for Subtask 2-------------------------\n");	//READ_DATA_FROM_UFS(1);//	APP_DEBUG("<----------------------------------------------------\n");//	APP_DEBUG("<----------------------------------------------------\n");		    //Ql_UART_Open(UART_PORT2, 19200, FC_NONE);	Ql_UART_OpenEx(UART_PORT2, &port2_dcb);	//Ql_Debug_Trace("\r\n<--OpenCPU: transpass test!%s VERSION: %s-->\r\n",MODEL_NAME, VERSION);  //  APP_DEBUG("\r\n<-- multitask: example_task1_entry -->\r\n");    	TIMER_INIITIALIZE_SUBTASK2();	while(keepGoing)    {            Ql_OS_GetMessage(&subtask1_msg);	//	APP_DEBUG("<-- Task RCV\r\n");        switch(subtask1_msg.message)        {            case MSG_ID_USER_DATA:            {             /*  APP_DEBUG("\r\n<--Sub task 1 recv MSG: SrcId=%d,MsgID=%d Data1=%d, Data2=%d-->\r\n", \                        subtask1_msg.srcTaskId, \                        subtask1_msg.message,\                        subtask1_msg.param1, \						subtask1_msg.param2);    */				APP_DEBUG("\r\n <-- Msg receive for subtask 1 -->\r\n");						} break;						case MSG_ID_UART_AND_TIMER_INIT:			{			//	APP_DEBUG("\r\n<--Sub task 1 recv MSG: SrcId=%d,MsgID=%d Data1=%d, Data2=%d-->\r\n", \                        subtask1_msg.srcTaskId, \                        subtask1_msg.message,\                        subtask1_msg.param1, \						subtask1_msg.param2);										switch(subtask1_msg.param1)				{					//Case 0 For Timer Initialize					case 0:					{						ret = Ql_Timer_Start(Stack_timer,ST_Interval,TRUE);							if(ret < 0)						{							APP_DEBUG("\r\n<--failed!! stack timer Ql_Timer_Start ret=%d-->\r\n",ret);        						}					//	APP_DEBUG("\r\n<-- Timer start for %d msec -->\r\n",ST_Interval);					}					break;										//Case 1 For Serial Initialize					case 1:					{						Ql_UART_OpenEx(UART_PORT2, &port2_dcb);						APP_DEBUG("\r\n<--OpenCPU: PORT2 INITIALIZE %s VERSION: %s-->\r\n",MODEL_NAME, VERSION);					}					break;										default: APP_DEBUG("<-- Default MSG_ID_UART_AND_TIMER_INIT proc SubTask 1\r\n");					break;				}								}			break;						case MSG_ID_FOTA_DINIT_CONF:			{				APP_DEBUG("<-- STOP TIMER & COMMUNICATION PORT\r\n");								ret = Ql_Timer_Stop(Stack_timer);				if(ret < 0)				{					  APP_DEBUG("\r\n<--failed!! stack timer Ql_Timer_Stop ret=%d-->\r\n",ret);           				}				APP_DEBUG("\r\n<--stack timer Ql_Timer_Stop(ID=%d,) ret=%d-->\r\n",Stack_timer,ret);   								ret = Ql_Timer_Stop(Stack_timer2);				if(ret < 0)				{					  APP_DEBUG("\r\n<--failed!! stack timer Ql_Timer_Stop ret=%d-->\r\n",ret);           				}				APP_DEBUG("\r\n<--stack timer Ql_Timer_Stop(ID=%d,) ret=%d-->\r\n",Stack_timer2,ret);   								ret = Ql_Timer_Stop(Stack_timer3);				if(ret < 0)				{					  APP_DEBUG("\r\n<--failed!! stack timer Ql_Timer_Stop ret=%d-->\r\n",ret);           				}				APP_DEBUG("\r\n<--stack timer Ql_Timer_Stop(ID=%d,) ret=%d-->\r\n",Stack_timer3,ret);   								Ql_UART_Close(UART_PORT2);				Ql_UART_ClrRxBuffer(UART_PORT2); 			}			break;                               default:                break;        }    }    }static void SIM_Card_State_Ind(u32 sim_stat){    switch (sim_stat)    {    case SIM_STAT_NOT_INSERTED:        APP_DEBUG("<-- SIM Card Status: NOT INSERTED -->\r\n");    	break;    case SIM_STAT_READY:        APP_DEBUG("<-- SIM Card Status: READY -->\r\n");        break;    case SIM_STAT_PIN_REQ:        APP_DEBUG("<-- SIM Card Status: SIM PIN -->\r\n");        break;    case SIM_STAT_PUK_REQ:        APP_DEBUG("<-- SIM Card Status: SIM PUK -->\r\n");        break;    case SIM_STAT_PH_PIN_REQ:        APP_DEBUG("<-- SIM Card Status: PH-SIM PIN -->\r\n");        break;    case SIM_STAT_PH_PUK_REQ:        APP_DEBUG("<-- SIM Card Status: PH-SIM PUK -->\r\n");        break;    case SIM_STAT_PIN2_REQ:        APP_DEBUG("<-- SIM Card Status: SIM PIN2 -->\r\n");        break;    case SIM_STAT_PUK2_REQ:        APP_DEBUG("<-- SIM Card Status: SIM PUK2 -->\r\n");        break;    case SIM_STAT_BUSY:        APP_DEBUG("<-- SIM Card Status: BUSY -->\r\n");        break;    case SIM_STAT_NOT_READY:        APP_DEBUG("<-- SIM Card Status: NOT READY -->\r\n");        break;    default:        APP_DEBUG("<-- SIM Card Status: ERROR -->\r\n");        break;    }}void SET_SUB_TOPIC_DETAILS(){	//NO_OF_SUB_TOPIC = 2;	u8 *pointer;	u8* temp_topic[8];	//pointer = test_topic_array;	temp_topic[0] = (u8*)Ql_MEM_Alloc(sizeof(u8)*256);	temp_topic[1] = (u8*)Ql_MEM_Alloc(sizeof(u8)*256);	Ql_memcpy(temp_topic[0],test_topic_SUB_array[0],Ql_strlen(test_topic_SUB_array[0]));	Ql_memcpy(temp_topic[1],test_topic_PUB_array[0],Ql_strlen(test_topic_PUB_array[0]));	}void READ_DATA_FROM_UFS(int val_mem){	s32 ret = -1;	s32 handle = -1;	u32 readenLen = 0,length_1 = 100;	u32 i, j ;	u8 file_name[50];	u8 *filename;	u8 *filename1  = "sermod.txt";	u8 *filename2  = "time_store.txt";//	u8 *filename3  = "modadd.txt";	u8 *filename4  = "id.txt";	u8 *filename5  = "apn.txt";	u8 *filename6  = "ip.txt";	u8 *filename7  = "port.txt";	u8 *filename8  = "time.txt";	u8 *filename9  = "count.txt";	u8 *filename10 = "ip1.txt";	u8 *filename11 = "port1.txt";	u8 *filename12 = "Fota.txt";	u8 *filename13 = "Timestamp_sub.txt";	u8 *filename14 = "url.txt";	u8 *filename15 = "Slave_1.txt";	u8 *filename16 = "Slave_2.txt";	u8 *filename17 = "Slave_3.txt";	u8 *filename18 = "Slave_4.txt";		u8 filePath[LENGTH] = {0};	if((val_mem == 15) || (val_mem == 16) || (val_mem == 17) || (val_mem == 18))	{	//	length_1 = 8 * 1024;	    length_1 = 2*1024 ;	}	//copy the string into strbuf	u8 strBuf[length_1] ;  	for(i=0; i<length_1; i++)	{		strBuf[i] = '\0';	}//	APP_DEBUG("<----------------------------------------------------\r\n");    APP_DEBUG("\r\n");//	APP_DEBUG("<-- FILE NO: %d\r\n", val_mem)		if(val_mem == 1)	{		Ql_sprintf(filePath,"%s\\%s\0",PATH_ROOT,filename1);		Ql_sprintf(filePath1,"%s\\%s\0",PATH_ROOT,filename1);        strcpy(file_name,"GET_MODBUS_DETAILS");	}	else if(val_mem == 2)	{		Ql_sprintf(filePath,"%s\\%s\0",PATH_ROOT,filename2);		Ql_sprintf(filePath2,"%s\\%s\0",PATH_ROOT,filename2);		strcpy(file_name,"Get_Store_Time");	}/*	else if(val_mem == 3)	{		Ql_sprintf(filePath,"%s\\%s\0",PATH_ROOT,filename3);		Ql_sprintf(filePath3,"%s\\%s\0",PATH_ROOT,filename3); 	}*/	else if(val_mem == 4)	{		Ql_sprintf(filePath,"%s\\%s\0",PATH_ROOT,filename4);		Ql_sprintf(filePath4,"%s\\%s\0",PATH_ROOT,filename4);		strcpy(file_name,"Get_Device_ID");	}	else if(val_mem == 5)	{		Ql_sprintf(filePath,"%s\\%s\0",PATH_ROOT,filename5);		Ql_sprintf(filePath5,"%s\\%s\0",PATH_ROOT,filename5);		strcpy(file_name,"Get_APN");	}	else if(val_mem == 6)	{		Ql_sprintf(filePath,"%s\\%s\0",PATH_ROOT,filename6);		Ql_sprintf(filePath6,"%s\\%s\0",PATH_ROOT,filename6);		strcpy(file_name,"Get_IP");	}	else if(val_mem == 7)	{		Ql_sprintf(filePath,"%s\\%s\0",PATH_ROOT,filename7);		Ql_sprintf(filePath7,"%s\\%s\0",PATH_ROOT,filename7);		strcpy(file_name,"Get_PORT");	}	else if(val_mem == 8)	{		Ql_sprintf(filePath,"%s\\%s\0",PATH_ROOT,filename8);		Ql_sprintf(filePath8,"%s\\%s\0",PATH_ROOT,filename8);		strcpy(file_name,"Get_Time");	}	else if(val_mem == 9)	{		Ql_sprintf(filePath,"%s\\%s\0",PATH_ROOT,filename9);		Ql_sprintf(filePath9,"%s\\%s\0",PATH_ROOT,filename9);		strcpy(file_name,"Get_Count_Value");	}	else if(val_mem == 10)	{		Ql_sprintf(filePath,"%s\\%s\0",PATH_ROOT,filename10);		Ql_sprintf(filePath10,"%s\\%s\0",PATH_ROOT,filename10);		strcpy(file_name,"Get_IP1");	}	else if(val_mem == 11)	{		Ql_sprintf(filePath,"%s\\%s\0",PATH_ROOT,filename11);		Ql_sprintf(filePath11,"%s\\%s\0",PATH_ROOT,filename11);		strcpy(file_name,"Get_Port1");	}	else if(val_mem == 12)	{		Ql_sprintf(filePath,"%s\\%s\0",PATH_ROOT,filename12);		Ql_sprintf(filePath12,"%s\\%s\0",PATH_ROOT,filename12);		strcpy(file_name,"Get_Fota_Details");	}	else if(val_mem == 13)	{		Ql_sprintf(filePath,"%s\\%s\0",PATH_ROOT,filename13);		Ql_sprintf(filePath13,"%s\\%s\0",PATH_ROOT,filename13);		strcpy(file_name,"Get_Timestamp");	}	else if(val_mem == 14)	{		Ql_sprintf(filePath,"%s\\%s\0",PATH_ROOT,filename14);		Ql_sprintf(filePath14,"%s\\%s\0",PATH_ROOT,filename14);		strcpy(file_name,"Get_URL");	}	else if(val_mem == 15)	{		Ql_sprintf(filePath,"%s\\%s\0",PATH_ROOT,filename15);		Ql_sprintf(filePath15,"%s\\%s\0",PATH_ROOT,filename15);		strcpy(file_name,"Get_Slave1_Modbus_Details");	}	else if(val_mem == 16)	{		Ql_sprintf(filePath,"%s\\%s\0",PATH_ROOT,filename16);		Ql_sprintf(filePath16,"%s\\%s\0",PATH_ROOT,filename16);		strcpy(file_name,"Get_Slave2_Modbus_Details");	}	else if(val_mem == 17)	{		Ql_sprintf(filePath,"%s\\%s\0",PATH_ROOT,filename17);		Ql_sprintf(filePath17,"%s\\%s\0",PATH_ROOT,filename17);		strcpy(file_name,"Get_Slave3_Modbus_Details");	}	else if(val_mem == 18)	{		Ql_sprintf(filePath,"%s\\%s\0",PATH_ROOT,filename18);		Ql_sprintf(filePath18,"%s\\%s\0",PATH_ROOT,filename18);		strcpy(file_name,"Get_Slave4_Modbus_Details");	}	else{}//	APP_DEBUG("<-- filepath=%s -->\r\n", filePath);	APP_DEBUG("<-- filename=%s -->\r\n", file_name);    ret = Ql_FS_Check(filePath);    if(ret != QL_RET_OK)    {		APP_DEBUG("<-- does not exist creating file! -->\r\n", filePath);                 }	//open file if file does not exist ,creat it	handle = Ql_FS_Open(filePath,QL_FS_READ_WRITE |QL_FS_CREATE);    //APP_DEBUG("\r\n<--!! Ql_FS_Open  handle =%d -->\r\n",handle);	Ql_FS_Flush(handle);           ret = Ql_FS_Seek(handle,0,QL_FS_FILE_BEGIN);        //read file    ret = Ql_FS_Read(handle, strBuf, length_1, &readenLen); //   APP_DEBUG("<-- read_length=%d, read_Buffer=%s-->\r\n", readenLen, strBuf);	/*	if(readenLen==0)	{		APP_DEBUG("<-- buffer file is empty -->\r\n");	}*/	    Ql_FS_Close(handle);	//close file 		if(val_mem == 1)	{		if(readenLen==0)		{			APP_DEBUG("<-- buffer file is empty -->\r\n");		}		else		{			Ql_strcpy(strBuf_ser_mod, strBuf);						if(strBuf_ser_mod[0] == '\0')			{}			else			{				char *p=NULL, *q=NULL, *r=NULL, *s=NULL;								p = Ql_strstr(strBuf_ser_mod,"SLAVE-ID");				if(p)				{					char Temp_ID;					p = p + 9;										Temp_ID = ((p[0]-48) * 100) + ((p[1]-48) * 10) + (p[2] - 48); 									//	APP_DEBUG("<-- Temp_ID = %d\r\n", Temp_ID);										if(Temp_ID > 250)					{						APP_DEBUG("<-- ID IS GREATER THAN 250\r\n");					}					else					{						q = Ql_strstr(strBuf_ser_mod,"BAUDRATE");						if(q)						{							q = q + 9;														u32 Temp_Baudrate=0;															Temp_Baudrate = (((q[0]-48) * 100000) + ((q[1]-48) * 10000) + ((q[2] - 48)* 1000) +((q[3]-48) * 100) + ((q[4]-48) * 10) + (q[5] - 48));												//	APP_DEBUG("<-- Temp_Baudrate = %ld -->\r\n", Temp_Baudrate);														r = Ql_strstr(strBuf_ser_mod,"PARITY");							if(r)							{								r = r + 7;								char Temp_Parity;																Temp_Parity = *r - 48;															//	APP_DEBUG("<-- Temp_Parity = %d\r\n", Temp_Parity);																s = Ql_strstr(strBuf_ser_mod,"PROJ-NAME:");								if(s)								{																	char k;									s = s + 10;																		Ql_memset(MODEL_NAME, 0, sizeof(MODEL_NAME));																		for(k=0; k<25; k++)									{										if(s[k] == ',')										{											break;										}										MODEL_NAME[k] =  s[k];									}																		MODBUS_SLAVE_ID = Temp_ID;									port2_dcb.baudrate = Temp_Baudrate;									port2_dcb.parity = Temp_Parity;													APP_DEBUG("\r\n<-- MODBUS_SLAVE_ID=%d  PORT-BAUDRATE = %ld  PORT-PARITY = %d  MODEL_NAME = %s \r\n", MODBUS_SLAVE_ID, port2_dcb.baudrate, port2_dcb.parity, MODEL_NAME);								}								else{APP_DEBUG("<-- PROJECT NAME NOT DEFINED\r\n");}							}							else{APP_DEBUG("<-- PARITY NOT MATCH\r\n");}						}						else{APP_DEBUG("<-- BAUDRATE NOT MATCH\r\n");}					}				}				else{APP_DEBUG("<-- SLAVE-ID NOT MATCH\r\n");}			}        }			}	else if(val_mem == 2)	{		if(readenLen==0)		{			APP_DEBUG("<-- buffer file is empty -->\r\n");		}			else        {						Ql_strcpy(strBuf_time_store, strBuf);			if((strBuf_time_store[0] == '$') && (strBuf_time_store[13] == '#'))			{					APP_DEBUG("\r\n<-- strBut_Time_Store = %s", strBuf_time_store);								time.year     = (2000 + ((strBuf_time_store[11]-48) * 10) + (strBuf_time_store[12]-48)) ;				time.month    = ((strBuf_time_store[9]-48) * 10) + (strBuf_time_store[10]-48) ;				time.day      = ((strBuf_time_store[7]-48) * 10) + (strBuf_time_store[8]-48) ;				time.hour     = ((strBuf_time_store[1]-48) * 10) + (strBuf_time_store[2]-48) ;				time.minute   = ((strBuf_time_store[3]-48) * 10) + (strBuf_time_store[4]-48) ;				time.second   = ((strBuf_time_store[5]-48) * 10) + (strBuf_time_store[6]-48) ;				time.timezone = 0;			 				ret = Ql_SetLocalTime(&time);						APP_DEBUG("<-- Set Local Time (%d.%02d.%02d %02d:%02d:%02d timezone=%02d)=%d -->\n\r", time.year, time.month, time.day, time.hour, time.minute, time.second, time.timezone, ret);							//get local time				if(Ql_GetLocalTime(&time))				{					APP_DEBUG("<-- Get Local Time(%d.%02d.%02d %02d:%02d:%02d timezone=%02d)=%d -->\n\r",time.year, time.month, time.day, time.hour, time.minute, time.second, time.timezone, ret);				}				else				{					APP_DEBUG("\r\n<--failed !! Local time not determined -->\r\n");				}							INITIAL_RTC_TIME_SYNC_FLAG = 1;			}					else{APP_DEBUG("<-- STORED RTC TIME IS INVALID\r\n");}	    }	}	else if(val_mem == 4)	{		Ql_strcpy(strBuf_id, strBuf);		for(i=0; i<15; i++) 		{			if((strBuf_id[i] >= 48) && (strBuf_id[i] <= 57))  // 48 is an ASCII value of 0 and 57 is an ASCII value of 9			{				DEVICE_ID[i] = strBuf_id[i] ;			}			else{//APP_DEBUG("Invalid Device ID\r\n");			}			if(strBuf_id[i] == '\0'){break;}		}		APP_DEBUG("<-- READ_BUFF_DATA=%s\r\n",strBuf_id);		APP_DEBUG("<-- DEVICE ID=%s-->\r\n", DEVICE_ID);	}	else if(val_mem == 5)	{		Ql_strcpy(strBuf_apn, strBuf);		if(strBuf_apn[0] == '\0')		{}		else		{			for(i =0; i<25 ; i++)			{				APN_NAME[i] = strBuf_apn[i];				if('\0' == strBuf_apn[i]){break;}			}			Ql_memset(m_GprsConfig.apnName, 0x0, sizeof(m_GprsConfig.apnName));		//	APP_DEBUG("<-- APN BEFORE COPY= %s\r\n", m_GprsConfig.apnName);  			Ql_memcpy(m_GprsConfig.apnName, APN_NAME, Ql_strlen(APN_NAME));		//	APP_DEBUG("<-- APN AFTER COPY= %s\r\n", m_GprsConfig.apnName);		//	APP_DEBUG("<-- APN CHANGE\r\n");		}	//	APP_DEBUG("<-- READ_BUFF_DATA=%s\r\n",strBuf_apn);		APP_DEBUG("<-- DEVICE APN =%s\r\n", APN_NAME);		APP_DEBUG("<-- CONFIGURED APN =%s\r\n", m_GprsConfig.apnName);	}	else if(val_mem == 6)	{		Ql_strcpy(strBuf_ip, strBuf);		if(strBuf_ip[0] == '\0')		{}		else		{			for(i =0; i<15 ; i++)			{				m_SrvADDR[i] = strBuf_ip[i];				if('\0' == strBuf_ip[i]){break;}			}		//	APP_DEBUG("\n<-- IP1 CHANGE\r\n");		}	//	APP_DEBUG("<-- READ_BUFF_DATA=%s\r\n",strBuf_ip);		APP_DEBUG("<-- DEVICE IP1 =%s-->\r\n", m_SrvADDR);	}	else if(val_mem == 7)	{		Ql_strcpy(strBuf_port, strBuf);		if(strBuf_port[0] == '\0')		{}		else		{			for(i =0; i<10 ; i++)			{				m_SrvPort1[i] = strBuf_port[i];				if('\0' == strBuf_port[i]){break;}			}			m_SrvPort = PORT_VALUE_CAL(m_SrvPort1);		//	APP_DEBUG("<-- PORT1 CHANGE\r\n");		}	//	APP_DEBUG("<-- READ_BUFF_DATA=%s\r\n",strBuf_port);	//	APP_DEBUG("<-- PORT1 IN ARRAY=%s\r\n", m_SrvPort1);		APP_DEBUG("<-- PORT1 IN DECIMAL=%d\r\n", m_SrvPort);	}	else if(val_mem == 8)	{		Ql_strcpy(strBuf_time, strBuf);		if(strBuf_time[0] == '\0')		{}		else if(strBuf_time[3] < '6')		{			for(i =0; i<5 ; i++)			{				ST_Interval_1[i] = strBuf_time[i];				if('\0' == strBuf_time[i]){break;}			}			if(i == 5)			{				ST_Interval = CONVERT_TIME_BUFFER_TO_SECONDS_VALUE(strBuf_time);	//			APP_DEBUG("<-- TIME CHANGE\r\n");			}		}	//	APP_DEBUG("<-- READ_BUFF_DATA=%s\r\n",strBuf_time);		APP_DEBUG("<-- TIME1 IN ARRAY=%s\r\n", ST_Interval_1);		APP_DEBUG("<-- TIME1 IN mSEC=%d\r\n", ST_Interval_1);	}	else if(val_mem == 9)	{		Ql_strcpy(strBuf_Count, strBuf);		if(strBuf_Count[0] == '\0')		{			APP_DEBUG("<-- NO DATA STORE --> \r\n<-- STORE_DATA_COUNT: %d, LENGTH: %d -->\r\n",STORE_DATA_COUNT, STORE_DATA_LENGTH);		}		else		{			char *p = NULL, *q = NULL, *r = NULL;			p = Ql_strstr(strBuf_Count,"STORE DATA COUNT:");			if(p)			{				p = p + 17;								STORE_DATA_COUNT = (((p[0] -48) * 10000) + ((p[1] -48) * 1000) + ((p[2] - 48) * 100) + ((p[3] - 48) * 10) + (p[4] -48));								if(STORE_DATA_COUNT > 0)				{					DATA_STORE_FLAG = 1;				}			}						q = Ql_strstr(strBuf_Count,"LENGTH:");			if(q)			{				q = q + 7;								STORE_DATA_LENGTH = (((q[0] -48) * 10000) + ((q[1] -48) * 1000) + ((q[2] - 48) * 100) + ((q[3] - 48) * 10) + (q[4] -48));			}		}	}	else if(val_mem == 10)	{		Ql_strcpy(strBuf_ip, strBuf);		if(strBuf_ip[0] == '\0')		{}		else		{			for(i =0; i<15 ; i++)			{				m_SrvADDR_1[i] = strBuf_ip[i];				if('\0' == strBuf_ip[i]){break;}			}	//		APP_DEBUG("<-- CHANGE IP2\r\n");		}	//	APP_DEBUG("<-- READ_BUFF_DATA=%s\r\n",strBuf_ip);		APP_DEBUG("<-- DEVICE IP2 =%s-->\r\n", m_SrvADDR_1);	}	else if(val_mem == 11)	{		if(readenLen==0)		{			APP_DEBUG("<-- buffer file is empty -->\r\n");		}		else		{			Ql_strcpy(strBuf_port, strBuf);			if(strBuf_port[0] == '\0')			{}			else			{				for(i =0; i<15 ; i++)				{					m_SrvPort12[i] = strBuf_port[i];					if('\0' == strBuf_port[i]){break;}				}				m_SrvPort_1 = PORT_VALUE_CAL(m_SrvPort12);		    //	APP_DEBUG("<-- CHANGE PORT2\r\n");			}		    //	APP_DEBUG("<-- READ_BUFF_DATA=%s\r\n",strBuf_port);		   //	APP_DEBUG("<-- PORT2 IN ARRAY=%s\r\n", m_SrvPort12);			APP_DEBUG("<-- PORT2 IN DECIMAL=%d\r\n", m_SrvPort_1);		}	}	else if(val_mem == 12)	{		if(readenLen==0)		{			APP_DEBUG("<-- buffer file is empty -->\r\n");		}		else		{			if((strBuf[0] == '\0') || (strBuf[0] == ','))			{				APP_DEBUG("<-- FOTA BUFFER EMPTY\r\n");			}			else if((strBuf[13] == ',') && (strBuf[15] == ','))			{				for(i=0; i<13; i++)				{					FOTA_STATUS_VARIABLE.MOBILE_NO[i] = strBuf[i];				}				strBuf[i] = 0;								FOTA_STATUS_VARIABLE.TRIGGER_STATUS = strBuf[14] - 48;				FOTA_STATUS_VARIABLE.SUCCESS_STATUS = strBuf[16] - 48;								APP_DEBUG("<-- FOTA_MOBILE_NO = %s, FOTA_TRIGGER_STATUS=%d, FOTA_SUCCESS_STATUS=%d\r\n",FOTA_STATUS_VARIABLE.MOBILE_NO, FOTA_STATUS_VARIABLE.TRIGGER_STATUS, FOTA_STATUS_VARIABLE.SUCCESS_STATUS);			}			else			{				APP_DEBUG("<-- FOTA BUFFER CONTAIN GARBAGE\r\n");			}		}	}	else if(val_mem == 13)	{		if(readenLen==0)		{			APP_DEBUG("<-- buffer file is empty -->\r\n");		}		else		{			if(strBuf[0] == 0)			{				APP_DEBUG("<-- TIMESTAMP BUFFER IS EMPTY\r\n");			}			else			{				char *p =NULL, i;								p = Ql_strstr(strBuf,"TIME_SUB_MSG=");				if(p)				{					p = p + 13;										if(*(p+14) != '#')					{						APP_DEBUG("<-- INVALID TIMESTAMP STORED\r\n");					}					else					{						Ql_memset(TIMESTAMP_SUB_MSG, 0, sizeof(TIMESTAMP_SUB_MSG));												for(i=0; i<14; i++)						{							TIMESTAMP_SUB_MSG[i] = *p;							p = p+1;						}						TIMESTAMP_SUB_MSG[i] =0;										}				}				else{APP_DEBUG("<-- NO CHANGE IN TIMESTAMP\r\n");}				APP_DEBUG("<-- CURRENT TIME_STAMP= %s\r\n", TIMESTAMP_SUB_MSG);			}		}	}/*	else if(val_mem == 14)	{		if(readenLen==0)		{			APP_DEBUG("<-- buffer file is empty -->\r\n");		}		else		{			if(strBuf[0] == 0)			{			//	APP_DEBUG("<-- HTTP URL BUFFER IS EMPTY\r\n");			}			else			{				char *p = NULL, *q=NULL;								p = Ql_strstr(strBuf,"HTTP_URL=");				if(p)				{					char i;					p = p + 9;										Ql_memset(HTTP_URL_ADDR, 0, sizeof(HTTP_URL_ADDR));					for(i=0; i<160; i++)					{						HTTP_URL_ADDR[i] = *p;						if(*p == 0)						{							break;						}						p = p + 1;					}					HTTP_URL_ADDR[i] = 0;										APP_DEBUG("<-- HTTP_URL_ADDR = %s\0", HTTP_URL_ADDR);				}				else{APP_DEBUG("<-- NO CHANGE FOR URL\r\n");}			}		}		}       */	else if(val_mem == 15)	{		if(readenLen==0)		{			APP_DEBUG("<-- buffer file is empty -->\r\n");		}		else		{			Ql_strcpy(strBuf_data, strBuf);						APP_DEBUG("File 15 = %s \r\n",strBuf_data);						if(strBuf_data[0] == '\0')			{}			else			{				char *p=NULL;				char *r=NULL;				char No_Of_Queries;				//05#1,3,00100,020#1,3,00134,016#1,3,00156,002#1,3,00164,002#1,3,00200,002#BAUDRATE#9600#PARITY#NONE#								p=strtok(strBuf_data,"#");				if(p)				{					No_Of_Queries=atoi(p); //atoi function converts chracter string into interger value. include stdlib.h for atoi										Total_No_Of_Queries = (int)No_Of_Queries;										if(Total_No_Of_Queries>99) 					{						APP_DEBUG("Modbus Error\r\n");						APP_DEBUG("Max Limit of Queries are 99\r\n");					}						//001,3,00100,020#001,3,00134,016#001,3,00156,002#001,3,00164,002#BAUDRATE#9600#PARITY#NONE#					else					{						p=strtok(NULL,"");												for(i=0; i<Total_No_Of_Queries; i++)						{							MODBUS_SLAVE_ID_BUFF[i] = (((p[0] - 48) * 100) + ((p[1] - 48) * 10) + (p[2] - 48)); 														FUNCTION_CODE[i] = (p[4] - 48);														MODBUS_ADDRESS[i] = (((p[6] - 48) * 10000) + ((p[7] - 48) * 1000) + ((p[8] - 48) * 100) + ((p[9] - 48) * 10) + ((p[10] - 48)));   							MODBUS_LEGTH[i] = (((p[12] - 48) * 100) + ((p[13] - 48) * 10) + (p[14] - 48));														p = p + 16;														APP_DEBUG("<-- POSITION %02d: MODBUS_SLAVE_ID = %03d, FUNCTION_CODE = %d, MODBUS_ADDRESS = %05d, MODBUS_LEGTH = %03d\r\n",i, MODBUS_SLAVE_ID_BUFF[i], FUNCTION_CODE[i], MODBUS_ADDRESS[i], MODBUS_LEGTH[i]);						}						count=i;						NO_OF_QUERY = Total_No_Of_Queries;						Slave_1_QN = Total_No_Of_Queries;						APP_DEBUG("Total Number of queries@@@@ is %d\r\n",Total_No_Of_Queries);						MOD_SLAVE[0] = MODBUS_SLAVE_ID_BUFF[Slave_1_QN - 1];						APP_DEBUG("MOD_SLAVE[0] = %s\r\n",MOD_SLAVE[0]);					//	APP_DEBUG("<--------------------------------------------\r\n");						MODBUS_STORE_PARAMETER_DETECTECTION_FLAG = 1;					}						}								else{APP_DEBUG("<--- Invalid data in file\r\n");}  // delete the file and create the file again			}		}	}	else if(val_mem == 16)	{		if(readenLen==0)		{			APP_DEBUG("<-- buffer file is empty -->\r\n");		}		else		{			Ql_strcpy(strBuf_data, strBuf);						if(strBuf_data[0] == '\0')			{}			else			{				char *p=NULL;				char *r=NULL;				char No_Of_Queries;								APP_DEBUG("Total Number of queries$$$ is %d\r\n",Total_No_Of_Queries);								p=strtok(strBuf_data,"#");				if(p)				{					No_Of_Queries=atoi(p); //atoi function converts chracter string into interger value. include stdlib.h for atoi					APP_DEBUG("Number of queries is %d\r\n",No_Of_Queries);					APP_DEBUG("Total Number of queries_1 is %d\r\n",Total_No_Of_Queries);					Total_No_Of_Queries= Total_No_Of_Queries + No_Of_Queries;					APP_DEBUG("Total Number of queries_2 is %d\r\n",Total_No_Of_Queries);										if(Total_No_Of_Queries>99) 					{						APP_DEBUG("Modbus Error\r\n");						APP_DEBUG("Max Limit of Queries are 99\r\n");					}											else					{											//001,3,00100,020#001,3,00134,016#001,3,00156,002#001,3,00164,002#BAUDRATE#9600#PARITY#NONE#						p=strtok(NULL,"");												for(i=count; i<Total_No_Of_Queries; i++)						{							MODBUS_SLAVE_ID_BUFF[i] = (((p[0] - 48) * 100) + ((p[1] - 48) * 10) + (p[2] - 48)); 														FUNCTION_CODE[i] = (p[4] - 48);														MODBUS_ADDRESS[i] = (((p[6] - 48) * 10000) + ((p[7] - 48) * 1000) + ((p[8] - 48) * 100) + ((p[9] - 48) * 10) + ((p[10] - 48)));   							MODBUS_LEGTH[i] = (((p[12] - 48) * 100) + ((p[13] - 48) * 10) + (p[14] - 48));														p = p + 16;														APP_DEBUG("<-- POSITION %02d: MODBUS_SLAVE_ID = %03d, FUNCTION_CODE = %d, MODBUS_ADDRESS = %05d, MODBUS_LEGTH = %03d\r\n",i, MODBUS_SLAVE_ID_BUFF[i], FUNCTION_CODE[i], MODBUS_ADDRESS[i], MODBUS_LEGTH[i]);						}						count=i;						NO_OF_QUERY = Total_No_Of_Queries;						Slave_2_QN = Total_No_Of_Queries;					//	APP_DEBUG("<--------------------------------------------\r\n");					    MOD_SLAVE[1] = MODBUS_SLAVE_ID_BUFF[Slave_2_QN - 1];						APP_DEBUG("MOD_SLAVE[1] = %s\r\n",MOD_SLAVE[1]);						MODBUS_STORE_PARAMETER_DETECTECTION_FLAG = 1; 					}						}								else{APP_DEBUG("<-- COMMAND NOT RCV FOR MODBUSS ADDRESS\r\n");}			}		}	}    else if(val_mem == 17)	{		if(readenLen==0)		{			APP_DEBUG("<-- buffer file is empty -->\r\n");		}		else		{				Ql_strcpy(strBuf_data, strBuf);						if(strBuf_data[0] == '\0')			{}			else			{				char *p=NULL;				char *r=NULL;				char No_Of_Queries;												p=strtok(strBuf_data,"#");				if(p)				{					No_Of_Queries=atoi(p); //atoi function converts chracter string into interger value. include stdlib.h for atoi										Total_No_Of_Queries= Total_No_Of_Queries + No_Of_Queries;										if(Total_No_Of_Queries>99) 					{						APP_DEBUG("Modbus Error\r\n");						APP_DEBUG("Max Limit of Queries are 99\r\n");					}											else					{											//001,3,00100,020#001,3,00134,016#001,3,00156,002#001,3,00164,002#BAUDRATE#9600#PARITY#NONE#						p=strtok(NULL,"");												for(i=count; i<Total_No_Of_Queries; i++)						{							MODBUS_SLAVE_ID_BUFF[i] = (((p[0] - 48) * 100) + ((p[1] - 48) * 10) + (p[2] - 48)); 														FUNCTION_CODE[i] = (p[4] - 48);														MODBUS_ADDRESS[i] = (((p[6] - 48) * 10000) + ((p[7] - 48) * 1000) + ((p[8] - 48) * 100) + ((p[9] - 48) * 10) + ((p[10] - 48)));   							MODBUS_LEGTH[i] = (((p[12] - 48) * 100) + ((p[13] - 48) * 10) + (p[14] - 48));														p = p + 16;														APP_DEBUG("<-- POSITION %02d: MODBUS_SLAVE_ID = %03d, FUNCTION_CODE = %d, MODBUS_ADDRESS = %05d, MODBUS_LEGTH = %03d\r\n",i, MODBUS_SLAVE_ID_BUFF[i], FUNCTION_CODE[i], MODBUS_ADDRESS[i], MODBUS_LEGTH[i]);						}						count=i;						NO_OF_QUERY = Total_No_Of_Queries;						Slave_3_QN = Total_No_Of_Queries;					//	APP_DEBUG("<--------------------------------------------\r\n");					    MOD_SLAVE[2] = MODBUS_SLAVE_ID_BUFF[Slave_3_QN - 1];						APP_DEBUG("MOD_SLAVE[2] = %s\r\n",MOD_SLAVE[2]);						MODBUS_STORE_PARAMETER_DETECTECTION_FLAG = 1;					}						}								else{APP_DEBUG("<-- COMMAND NOT RCV FOR MODBUSS ADDRESS\r\n");}			}		}	}    else if(val_mem == 18)	{		if(readenLen==0)		{			APP_DEBUG("<-- buffer file is empty -->\r\n");		}		else		{			Ql_strcpy(strBuf_data, strBuf);						if(strBuf_data[0] == '\0')			{}			else			{				char *p=NULL;				char *r=NULL;				char No_Of_Queries;												p=strtok(strBuf_data,"#");				if(p)				{					No_Of_Queries=atoi(p); //atoi function converts chracter string into interger value. include stdlib.h for atoi										Total_No_Of_Queries= Total_No_Of_Queries + No_Of_Queries;										if(Total_No_Of_Queries>99) 					{						APP_DEBUG("<-- Modbus Error -->\r\n");						APP_DEBUG("<-- Max Limit of Queries are 99 -->\r\n");					}											else					{											//001,3,00100,020#001,3,00134,016#001,3,00156,002#001,3,00164,002#BAUDRATE#9600#PARITY#NONE#						p=strtok(NULL,"");												for(i=count; i<Total_No_Of_Queries; i++)						{							MODBUS_SLAVE_ID_BUFF[i] = (((p[0] - 48) * 100) + ((p[1] - 48) * 10) + (p[2] - 48)); 														FUNCTION_CODE[i] = (p[4] - 48);														MODBUS_ADDRESS[i] = (((p[6] - 48) * 10000) + ((p[7] - 48) * 1000) + ((p[8] - 48) * 100) + ((p[9] - 48) * 10) + ((p[10] - 48)));   							MODBUS_LEGTH[i] = (((p[12] - 48) * 100) + ((p[13] - 48) * 10) + (p[14] - 48));														p = p + 16;														APP_DEBUG("<-- POSITION %02d: MODBUS_SLAVE_ID = %03d, FUNCTION_CODE = %d, MODBUS_ADDRESS = %05d, MODBUS_LEGTH = %03d\r\n",i, MODBUS_SLAVE_ID_BUFF[i], FUNCTION_CODE[i], MODBUS_ADDRESS[i], MODBUS_LEGTH[i]);						}						count=i;						NO_OF_QUERY = Total_No_Of_Queries;						Slave_4_QN = Total_No_Of_Queries;					//	APP_DEBUG("<--------------------------------------------\r\n");					    MOD_SLAVE[3] = MODBUS_SLAVE_ID_BUFF[Slave_4_QN - 1];						APP_DEBUG("MOD_SLAVE[3] = %s\r\n",MOD_SLAVE[3]);						MODBUS_STORE_PARAMETER_DETECTECTION_FLAG = 1;					}						}								else{APP_DEBUG("<-- COMMAND NOT RCV FOR MODBUSS ADDRESS\r\n");}			}		}		}	 Ql_FS_Close(handle);  	//APP_DEBUG("<----------------------------------------------------\r\n");}void WRITE_DATA_TO_UFS(int val_mem1,char writeBuffer[]){	u32 writenLen = 0;	u32 readenLen = 0;	s32 position = 0;    	s32 handle = -1;	u8 strBuf[LENGTH] = {0},ret;						//APP_DEBUG("1234");			switch(val_mem1)	{		case 1: handle = Ql_FS_Open(filePath1,QL_FS_READ_WRITE |QL_FS_CREATE );			//	APP_DEBUG("\r\n<--!! Ql_FS_Open  handle =%d -->\r\n",handle);			//	APP_DEBUG("\r\n<--filepath=%s -->\r\n", filePath1);				break;						case 2: handle = Ql_FS_Open(filePath2,QL_FS_READ_WRITE |QL_FS_CREATE );			//	APP_DEBUG("\r\n<--!! Ql_FS_Open  handle =%d -->\r\n",handle);			//	APP_DEBUG("\r\n<--filepath=%s -->\r\n", filePath2);				break;						case 3: handle = Ql_FS_Open(filePath3,QL_FS_READ_WRITE |QL_FS_CREATE );			//	APP_DEBUG("\r\n<--!! Ql_FS_Open  handle =%d -->\r\n",handle);			//	APP_DEBUG("\r\n<--filepath=%s -->\r\n", filePath3);				break;						case 4: handle = Ql_FS_Open(filePath4,QL_FS_READ_WRITE |QL_FS_CREATE );			//	APP_DEBUG("\r\n<--!! Ql_FS_Open  handle =%d -->\r\n",handle);			//	APP_DEBUG("\r\n<--filepath=%s -->\r\n", filePath4);				break;				case 5: handle = Ql_FS_Open(filePath5,QL_FS_READ_WRITE |QL_FS_CREATE );			//	APP_DEBUG("\r\n<--!! Ql_FS_Open  handle =%d -->\r\n",handle);			//	APP_DEBUG("\r\n<--filepath=%s -->\r\n", filePath5);				break;				case 6: handle = Ql_FS_Open(filePath6,QL_FS_READ_WRITE |QL_FS_CREATE );			//	APP_DEBUG("\r\n<--!! Ql_FS_Open  handle =%d -->\r\n",handle);			//	APP_DEBUG("\r\n<--filepath=%s -->\r\n", filePath6);				break;				case 7: handle = Ql_FS_Open(filePath7,QL_FS_READ_WRITE |QL_FS_CREATE );			//	APP_DEBUG("\r\n<--!! Ql_FS_Open  handle =%d -->\r\n",handle);			//	APP_DEBUG("\r\n<--filepath=%s -->\r\n", filePath7);				break;					case 8: handle = Ql_FS_Open(filePath8,QL_FS_READ_WRITE |QL_FS_CREATE );			//	APP_DEBUG("\r\n<--!! Ql_FS_Open  handle =%d -->\r\n",handle);			//	APP_DEBUG("\r\n<--filepath=%s -->\r\n", filePath8);				break;				case 9: handle = Ql_FS_Open(filePath9,QL_FS_READ_WRITE |QL_FS_CREATE );			//	APP_DEBUG("\r\n<--!! Ql_FS_Open  handle =%d -->\r\n",handle);			//	APP_DEBUG("\r\n<--filepath=%s -->\r\n", filePath9);				break;					case 10: handle = Ql_FS_Open(filePath10,QL_FS_READ_WRITE |QL_FS_CREATE );				APP_DEBUG("\r\n<--!! Ql_FS_Open  handle =%d -->\r\n",handle);				APP_DEBUG("\r\n<--filepath=%s -->\r\n", filePath10);				break;						case 11: handle = Ql_FS_Open(filePath11,QL_FS_READ_WRITE |QL_FS_CREATE );			//	APP_DEBUG("\r\n<--!! Ql_FS_Open  handle =%d -->\r\n",handle);			//	APP_DEBUG("\r\n<--filepath=%s -->\r\n", filePath11);				break;				case 12: handle = Ql_FS_Open(filePath12,QL_FS_READ_WRITE |QL_FS_CREATE );			//	APP_DEBUG("\r\n<--!! Ql_FS_Open  handle =%d -->\r\n",handle);			//	APP_DEBUG("\r\n<--filepath=%s -->\r\n", filePath12);				break;						case 13: handle = Ql_FS_Open(filePath13,QL_FS_READ_WRITE |QL_FS_CREATE );			//	APP_DEBUG("\r\n<--!! Ql_FS_Open  handle =%d -->\r\n",handle);			//	APP_DEBUG("\r\n<--filepath=%s -->\r\n", filePath13);				break;			case 14: handle = Ql_FS_Open(filePath14,QL_FS_READ_WRITE |QL_FS_CREATE );			//	APP_DEBUG("\r\n<--!! Ql_FS_Open  handle =%d -->\r\n",handle);			//	APP_DEBUG("\r\n<--filepath=%s -->\r\n", filePath14);				break;				case 15: handle = Ql_FS_Open(filePath15,QL_FS_READ_WRITE |QL_FS_CREATE );			//	APP_DEBUG("\r\n<--!! Ql_FS_Open  handle =%d -->\r\n",handle);			//	APP_DEBUG("\r\n<--filepath=%s -->\r\n", filePath15);				break;						case 16: handle = Ql_FS_Open(filePath16,QL_FS_READ_WRITE |QL_FS_CREATE );			//	APP_DEBUG("\r\n<--!! Ql_FS_Open  handle =%d -->\r\n",handle);			//	APP_DEBUG("\r\n<--filepath=%s -->\r\n", filePath16);				break;			case 17: handle = Ql_FS_Open(filePath17,QL_FS_READ_WRITE |QL_FS_CREATE );			//	APP_DEBUG("\r\n<--!! Ql_FS_Open  handle =%d -->\r\n",handle);			//	APP_DEBUG("\r\n<--filepath=%s -->\r\n", filePath17);				break;				case 18: handle = Ql_FS_Open(filePath18,QL_FS_READ_WRITE |QL_FS_CREATE );			//	APP_DEBUG("\r\n<--!! Ql_FS_Open  handle =%d -->\r\n",handle);			//	APP_DEBUG("\r\n<--filepath=%s -->\r\n", filePath18);				break;	 		break;				default:break;	}	Ql_FS_Flush(handle);       	ret = Ql_FS_Seek(handle,0,QL_FS_FILE_BEGIN);//	APP_DEBUG("\r\n<--!! Ql_FS_Seek   ret =%d-->\r\n",ret);    	position = Ql_FS_GetFilePosition(handle);//	APP_DEBUG("\r\n<--!! Ql_FS_GetFilePosition   position =%d-->\r\n",position);	ret = Ql_FS_Truncate(handle);	 ret = Ql_FS_Write(handle, writeBuffer, Ql_strlen(writeBuffer), &writenLen);//	APP_DEBUG("\r\n<--!! Ql_FS_Write  ret =%d  writenLen =%d-->\r\n",ret,writenLen);	Ql_FS_Flush(handle);       	ret = Ql_FS_Seek(handle,0,QL_FS_FILE_BEGIN);    	ret = Ql_FS_Read(handle, strBuf, LENGTH, &readenLen);//	APP_DEBUG("<-- Read length=%d, Read Buffer=%s -->\r\n",readenLen, strBuf);	Ql_FS_Close(handle);}void SEND_SMS(int val_mem1, char aReplyCon1[],char aPhNum1[]){	s32 iResult = 0 ;    u32 uMsgRef = 0;	if (!Ql_strstr(aPhNum1, "10086"))  // Not reply SMS from operator        {            APP_DEBUG("<-- Replying SMS... -->\r\n");            iResult = RIL_SMS_SendSMS_Text(aPhNum1, Ql_strlen(aPhNum1),LIB_SMS_CHARSET_GSM,(u8*)aReplyCon1,Ql_strlen(aReplyCon1),&uMsgRef);            if (iResult != RIL_AT_SUCCESS)            {                APP_DEBUG("RIL_SMS_SendSMS_Text FAIL! iResult:%u\r\n",iResult);                return;            }            APP_DEBUG("<-- RIL_SMS_SendTextSMS OK. uMsgRef:%d -->\r\n", uMsgRef);        }}void SET_MODBUS_PARAMETER() {          NO_OF_QUERY = 55; 		MODBUS_SLAVE_ID_BUFF[0] = 1;  FUNCTION_CODE[0]  = 1; MODBUS_ADDRESS[0]  = 209;   MODBUS_LEGTH[0]  = 1; 	MODBUS_SLAVE_ID_BUFF[1] = 1;  FUNCTION_CODE[1]  = 1; MODBUS_ADDRESS[1]  = 211;   MODBUS_LEGTH[1]  = 1;	MODBUS_SLAVE_ID_BUFF[2] = 1;  FUNCTION_CODE[2]  = 1; MODBUS_ADDRESS[2]  = 212;   MODBUS_LEGTH[2]  = 1;	MODBUS_SLAVE_ID_BUFF[3] = 1;  FUNCTION_CODE[3]  = 1; MODBUS_ADDRESS[3]  = 213;   MODBUS_LEGTH[3]  = 1;	MODBUS_SLAVE_ID_BUFF[4] = 1;  FUNCTION_CODE[4]  = 1; MODBUS_ADDRESS[4]  = 214;   MODBUS_LEGTH[4]  = 1;	MODBUS_SLAVE_ID_BUFF[5] = 1;  FUNCTION_CODE[5]  = 1; MODBUS_ADDRESS[5]  = 215;   MODBUS_LEGTH[5]  = 1;	MODBUS_SLAVE_ID_BUFF[6] = 1;  FUNCTION_CODE[6]  = 1; MODBUS_ADDRESS[6]  = 216;   MODBUS_LEGTH[6]  = 1;	MODBUS_SLAVE_ID_BUFF[7] = 1;  FUNCTION_CODE[7]  = 1; MODBUS_ADDRESS[7]  = 217;   MODBUS_LEGTH[7]  = 1;  	MODBUS_SLAVE_ID_BUFF[8] = 1;  FUNCTION_CODE[8]  = 1; MODBUS_ADDRESS[8]  = 219;   MODBUS_LEGTH[8]  = 1;	MODBUS_SLAVE_ID_BUFF[9] = 1;  FUNCTION_CODE[9]  = 1; MODBUS_ADDRESS[9]  = 220;   MODBUS_LEGTH[9]  = 1;	MODBUS_SLAVE_ID_BUFF[10] = 1;  FUNCTION_CODE[10]  = 1; MODBUS_ADDRESS[10]  = 52;   MODBUS_LEGTH[10]  = 1;	MODBUS_SLAVE_ID_BUFF[11] = 1;  FUNCTION_CODE[11]  = 1; MODBUS_ADDRESS[11]  = 53;   MODBUS_LEGTH[11]  = 1;	MODBUS_SLAVE_ID_BUFF[12] = 1;  FUNCTION_CODE[12]  = 1; MODBUS_ADDRESS[12]  = 54;   MODBUS_LEGTH[12]  = 1;	MODBUS_SLAVE_ID_BUFF[13] = 1;  FUNCTION_CODE[13]  = 1; MODBUS_ADDRESS[13]  = 55;   MODBUS_LEGTH[13]  = 1;	MODBUS_SLAVE_ID_BUFF[14] = 1;  FUNCTION_CODE[14]  = 1; MODBUS_ADDRESS[14]  = 56;   MODBUS_LEGTH[14]  = 1;	MODBUS_SLAVE_ID_BUFF[15] = 1;  FUNCTION_CODE[15]  = 1; MODBUS_ADDRESS[15]  = 57;   MODBUS_LEGTH[15]  = 1;	MODBUS_SLAVE_ID_BUFF[16] = 1;  FUNCTION_CODE[16]  = 1; MODBUS_ADDRESS[16]  = 58;   MODBUS_LEGTH[16]  = 1;	MODBUS_SLAVE_ID_BUFF[17] = 1;  FUNCTION_CODE[17]  = 1; MODBUS_ADDRESS[17]  = 46;   MODBUS_LEGTH[17]  = 1;	MODBUS_SLAVE_ID_BUFF[18] = 1;  FUNCTION_CODE[18]  = 1; MODBUS_ADDRESS[18]  = 49;   MODBUS_LEGTH[18]  = 1;	MODBUS_SLAVE_ID_BUFF[19] = 1;  FUNCTION_CODE[19]  = 1; MODBUS_ADDRESS[19]  = 65;   MODBUS_LEGTH[19]  = 1;	MODBUS_SLAVE_ID_BUFF[20] = 1;  FUNCTION_CODE[20]  = 1; MODBUS_ADDRESS[20]  = 66;   MODBUS_LEGTH[20]  = 1;	MODBUS_SLAVE_ID_BUFF[21] = 1;  FUNCTION_CODE[21]  = 1; MODBUS_ADDRESS[21]  = 67;   MODBUS_LEGTH[21]  = 1;	MODBUS_SLAVE_ID_BUFF[22] = 1;  FUNCTION_CODE[22]  = 1; MODBUS_ADDRESS[22]  = 68;   MODBUS_LEGTH[22]  = 1;	MODBUS_SLAVE_ID_BUFF[23] = 1;  FUNCTION_CODE[23]  = 1; MODBUS_ADDRESS[23]  = 70;   MODBUS_LEGTH[23]  = 1;	MODBUS_SLAVE_ID_BUFF[24] = 1;  FUNCTION_CODE[24]  = 1; MODBUS_ADDRESS[24]  = 1;   MODBUS_LEGTH[24]  = 1;	MODBUS_SLAVE_ID_BUFF[25] = 1;  FUNCTION_CODE[25]  = 1; MODBUS_ADDRESS[25]  = 51;   MODBUS_LEGTH[25]  = 1;	MODBUS_SLAVE_ID_BUFF[26] = 1;  FUNCTION_CODE[26]  = 1; MODBUS_ADDRESS[26]  = 52;   MODBUS_LEGTH[26]  = 1;	MODBUS_SLAVE_ID_BUFF[27] = 1;  FUNCTION_CODE[27]  = 3; MODBUS_ADDRESS[27]  = 1601;   MODBUS_LEGTH[27]  = 2;    	MODBUS_SLAVE_ID_BUFF[28] = 1;  FUNCTION_CODE[28]  = 3; MODBUS_ADDRESS[28]  = 811;   MODBUS_LEGTH[28]  = 1;	MODBUS_SLAVE_ID_BUFF[29] = 1;  FUNCTION_CODE[29]  = 3; MODBUS_ADDRESS[29]  = 511;   MODBUS_LEGTH[29]  = 1;    	MODBUS_SLAVE_ID_BUFF[30] = 1;  FUNCTION_CODE[30]  = 3; MODBUS_ADDRESS[30]  = 521;   MODBUS_LEGTH[30]  = 1;	MODBUS_SLAVE_ID_BUFF[31] = 1;  FUNCTION_CODE[31]  = 3; MODBUS_ADDRESS[31]  = 531;   MODBUS_LEGTH[31]  = 1;	MODBUS_SLAVE_ID_BUFF[32] = 1;  FUNCTION_CODE[32]  = 3; MODBUS_ADDRESS[32]  = 541;   MODBUS_LEGTH[32]  = 1;	MODBUS_SLAVE_ID_BUFF[33] = 1;  FUNCTION_CODE[33]  = 3; MODBUS_ADDRESS[33]  = 551;   MODBUS_LEGTH[33]  = 1;	MODBUS_SLAVE_ID_BUFF[34] = 1;  FUNCTION_CODE[34]  = 3; MODBUS_ADDRESS[34]  = 561;   MODBUS_LEGTH[34]  = 1;	MODBUS_SLAVE_ID_BUFF[35] = 1;  FUNCTION_CODE[35]  = 3; MODBUS_ADDRESS[35]  = 571;   MODBUS_LEGTH[35]  = 1;	MODBUS_SLAVE_ID_BUFF[36] = 1;  FUNCTION_CODE[36]  = 3; MODBUS_ADDRESS[36]  = 621;   MODBUS_LEGTH[36]  = 1;      	MODBUS_SLAVE_ID_BUFF[37] = 1;  FUNCTION_CODE[37]  = 3; MODBUS_ADDRESS[37]  = 591;   MODBUS_LEGTH[37]  = 1;	MODBUS_SLAVE_ID_BUFF[38] = 1;  FUNCTION_CODE[38]  = 3; MODBUS_ADDRESS[38]  = 601;   MODBUS_LEGTH[38]  = 1;	MODBUS_SLAVE_ID_BUFF[39] = 1;  FUNCTION_CODE[39]  = 3; MODBUS_ADDRESS[39]  = 581;   MODBUS_LEGTH[39]  = 1;	MODBUS_SLAVE_ID_BUFF[40] = 1;  FUNCTION_CODE[40]  = 3; MODBUS_ADDRESS[40]  = 761;   MODBUS_LEGTH[40]  = 1;	MODBUS_SLAVE_ID_BUFF[41] = 1;  FUNCTION_CODE[41]  = 3; MODBUS_ADDRESS[41]  = 741;   MODBUS_LEGTH[41]  = 1;	MODBUS_SLAVE_ID_BUFF[42] = 1;  FUNCTION_CODE[42]  = 3; MODBUS_ADDRESS[42]  = 671;   MODBUS_LEGTH[42]  = 1;	MODBUS_SLAVE_ID_BUFF[43] = 1;  FUNCTION_CODE[43]  = 3; MODBUS_ADDRESS[43]  = 823;   MODBUS_LEGTH[43]  = 1;	MODBUS_SLAVE_ID_BUFF[44] = 1;  FUNCTION_CODE[44]  = 3; MODBUS_ADDRESS[44]  = 831;   MODBUS_LEGTH[44]  = 1;	MODBUS_SLAVE_ID_BUFF[45] = 1;  FUNCTION_CODE[45]  = 3; MODBUS_ADDRESS[45]  = 611;   MODBUS_LEGTH[45]  = 1;    	MODBUS_SLAVE_ID_BUFF[46] = 1;  FUNCTION_CODE[46]  = 3; MODBUS_ADDRESS[46]  = 731;   MODBUS_LEGTH[46]  = 1;	MODBUS_SLAVE_ID_BUFF[47] = 1;  FUNCTION_CODE[47]  = 3; MODBUS_ADDRESS[47]  = 630;   MODBUS_LEGTH[47]  = 1;	MODBUS_SLAVE_ID_BUFF[48] = 1;  FUNCTION_CODE[48]  = 3; MODBUS_ADDRESS[48]  = 3;   MODBUS_LEGTH[48]  = 2;		MODBUS_SLAVE_ID_BUFF[49] = 2;  FUNCTION_CODE[49]  = 3; MODBUS_ADDRESS[49]  = 9002;   MODBUS_LEGTH[49]  = 2;	MODBUS_SLAVE_ID_BUFF[50] = 2;  FUNCTION_CODE[50]  = 3; MODBUS_ADDRESS[50]  = 3106;   MODBUS_LEGTH[50]  = 1;	MODBUS_SLAVE_ID_BUFF[51] = 2;  FUNCTION_CODE[51]  = 3; MODBUS_ADDRESS[51]  = 9614;   MODBUS_LEGTH[51]  = 1;	MODBUS_SLAVE_ID_BUFF[52] = 2;  FUNCTION_CODE[52]  = 3; MODBUS_ADDRESS[52]  = 9602;   MODBUS_LEGTH[52]  = 4;      	MODBUS_SLAVE_ID_BUFF[53] = 2;  FUNCTION_CODE[53]  = 3; MODBUS_ADDRESS[53]  = 3234;   MODBUS_LEGTH[53]  = 1;    	MODBUS_SLAVE_ID_BUFF[54] = 2;  FUNCTION_CODE[54]  = 3; MODBUS_ADDRESS[54]  = 7122;   MODBUS_LEGTH[54]  = 1; 	}void TIMER_INIITIALIZE(){	s32 ret;		ret = Ql_Timer_Register(Stack_timer4, TIMER_HANDLER, &m_param5);    if(ret <0)    {        APP_DEBUG("\r\n<--failed!!, Ql_Timer_Register: timer(%d) fail ,ret = %d -->\r\n",Stack_timer4,ret);    } //   APP_DEBUG("\r\n<--Register: timerId=%d, param = %d,ret = %d -->\r\n", Stack_timer4 ,m_param5,ret); 		ret = Ql_Timer_Register(LOGBOOK_TIMER, TIMER_HANDLER, &m_param6);    if(ret <0)    {        APP_DEBUG("\r\n<--failed!!, Ql_Timer_Register: timer(%d) fail ,ret = %d -->\r\n",LOGBOOK_TIMER,ret);    } //   APP_DEBUG("\r\n<--Register: timerId=%d, param = %d,ret = %d -->\r\n", LOGBOOK_TIMER ,m_param6,ret); 	    //register  a GP-Timer    ret = Ql_Timer_Register(GP_timer, TIMER_HANDLER, &m_param2);    if(ret <0)    {        APP_DEBUG("\r\n<--failed!!, Ql_Timer_RegisterFast: GP_timer(%d) fail ,ret = %d -->\r\n",GP_timer,ret);    }//    APP_DEBUG("\r\n<--RegisterFast: timerId=%d, param = %d,ret = %d -->\r\n", GP_timer ,m_param2,ret);		ret = Ql_Timer_Register(Fota_Reset_Timer, TIMER_HANDLER, &m_param7);    if(ret <0)    {        APP_DEBUG("\r\n<--failed!!, Ql_Timer_RegisterFast: GP_timer(%d) fail ,ret = %d -->\r\n",Fota_Reset_Timer,ret);    } //   APP_DEBUG("\r\n<--RegisterFast: timerId=%d, param = %d,ret = %d -->\r\n", Fota_Reset_Timer ,m_param7,ret);		// ret = Ql_Timer_Register(SWITCHING_485_TIMER, TIMER_HANDLER, &m_param8);    // if(ret <0)    // {        // APP_DEBUG("\r\n<--failed!!, Ql_Timer_RegisterFast: GP_timer(%d) fail ,ret = %d -->\r\n",SWITCHING_485_TIMER,ret);    // }    // APP_DEBUG("\r\n<--RegisterFast: timerId=%d, param = %d,ret = %d -->\r\n", SWITCHING_485_TIMER ,m_param8,ret);		ret = Ql_Timer_Register(MQTT_TIMER_ID, TIMER_HANDLER, &m_param8);    if(ret <0)    {        APP_DEBUG("\r\n<--failed!!, Ql_Timer_RegisterFast: GP_timer(%d) fail ,ret = %d -->\r\n",MQTT_TIMER_ID,ret);    } //   APP_DEBUG("\r\n<--RegisterFast: timerId=%d, param = %d,ret = %d -->\r\n", MQTT_TIMER_ID ,m_param8,ret);	}void TIMER_INIITIALIZE_SUBTASK2(){	s32 ret;	ret = Ql_Timer_Register(Stack_timer, TIMER_HANDLER_SUBTASK1, &m_param1);    if(ret <0)    {        APP_DEBUG("\r\n<--failed!!, Ql_Timer_Register: timer(%d) fail ,ret = %d -->\r\n",Stack_timer,ret);    }//    APP_DEBUG("\r\n<--Register: timerId=%d, param = %d,ret = %d -->\r\n", Stack_timer ,m_param1,ret); 		ret = Ql_Timer_Register(Stack_timer2, TIMER_HANDLER_SUBTASK1, &m_param3);    if(ret <0)    {        APP_DEBUG("\r\n<--failed!!, Ql_Timer_Register: timer(%d) fail ,ret = %d -->\r\n",Stack_timer2,ret);    } //   APP_DEBUG("\r\n<--Register: timerId=%d, param = %d,ret = %d -->\r\n", Stack_timer2 ,m_param3,ret); 		ret = Ql_Timer_Register(Stack_timer3, TIMER_HANDLER_SUBTASK1, &m_param4);    if(ret <0)    {        APP_DEBUG("\r\n<--failed!!, Ql_Timer_Register: timer(%d) fail ,ret = %d -->\r\n",Stack_timer3,ret);    } //   APP_DEBUG("\r\n<--Register: timerId=%d, param = %d,ret = %d -->\r\n", Stack_timer3 ,m_param4,ret); }void SYSTEM_INITIALIZE(){	s32 ret;	s32 iRet;	if(start_flag == 1)	{		start_flag = 0;		SYSTEM_INITIALIZE_WATCHDOG_FLAG = 1;				module_state = 3;	//	APP_DEBUG("\r\n module_state = %d \r\n", module_state);  	//	Location_Program();		Ql_UART_ClrRxBuffer(UART_PORT1);		Ql_UART_ClrRxBuffer(UART_PORT2);		Ql_UART_ClrRxBuffer(UART_PORT3);		PORT2_COMMUNICATION_FLAG = 1;		send_1 = 1;		send_flag2 = 1;		send_flag1 = 1;		QUERY_SEND_STAGE = 0;			// ret = Ql_Timer_Start(Stack_timer,ST_Interval,TRUE);			// if(ret < 0)		// {			// APP_DEBUG("\r\n<--failed!! stack timer Ql_Timer_Start ret=%d-->\r\n",ret);        		// }		// APP_DEBUG("\r\n<--stack timer Ql_Timer_Start(ID=%d,Interval=%d,) ret=%d-->\r\n",Stack_timer,ST_Interval,ret);						ret = Ql_Timer_Start(LOGBOOK_TIMER, LOGBOOK_Interval, TRUE);				if(ret < 0)		{			APP_DEBUG("\r\n<--failed!! stack timer5 Ql_Timer_Start ret=%d-->\r\n",ret);        		}	//	APP_DEBUG("\r\n<-- stack timer Ql_Timer_Start(ID=%d,Interval=%d,) ret=%d-->\r\n",LOGBOOK_TIMER,LOGBOOK_Interval,ret);	//	APP_DEBUG("\r\n<-- Logbook Timer start for %d msec -->\r\n", LOGBOOK_Interval);				module_state = 4;	//	APP_DEBUG("\r\n module_state = %d \r\n", module_state);  				Ql_Timer_Start(MQTT_TIMER_ID, MQTT_TIMER_PERIOD, TRUE);			if(ret < 0)		{			APP_DEBUG("\r\n<--failed!! stack timer Ql_Timer_Start ret=%d-->\r\n",ret);        		}	//	APP_DEBUG("\r\n<--stack timer Ql_Timer_Start(ID=%d,Interval=%d,) ret=%d-->\r\n",MQTT_TIMER_ID, MQTT_TIMER_PERIOD, ret);	//	APP_DEBUG("\r\n<-- MQTT Timer start for %d msec -->\r\n", MQTT_TIMER_PERIOD);				if(SERVER_PROTOCOL_SELECTION == 2)		{			GPRS_TCP_Program(CREATE_CONNECTION_PACKET);		}				//s_iPassTask = subtask1_id;		// if(fota_flag == 0)		// {			// iRet = Ql_OS_SendMessage(subtask1_id,MSG_ID_UART_AND_TIMER_INIT,0, 0);			// if(iRet <0)			// {				// APP_DEBUG("\r\n<--failed!!, Ql_OS_SendMessage(1, %d, %d) fail,  ret=%d-->\r\n", 0, 0, iRet);			// }			// APP_DEBUG("\r\n<--Ql_OS_SendMessage(%d, %d, %d) ret=%d-->\r\n",MSG_ID_USER_DATA,0, 0, iRet);		// }else{APP_DEBUG("<-- FOTA FLAG IS TRIGGER\r\n");}			}}void FOTA_upgrade(){	s32 ret;	//if(fota_flag == 1)	//{		// ret = Ql_Timer_Stop(Stack_timer);			// if(ret < 0)			// {				  // APP_DEBUG("\r\n<--failed!! stack timer Ql_Timer_Stop ret=%d-->\r\n",ret);           			// }			// APP_DEBUG("\r\n<--stack timer Ql_Timer_Stop(ID=%d,) ret=%d-->\r\n",Stack_timer,ret);   		//start_flag = 0;		//Ql_UART_Close(UART_PORT1);				// ret = Ql_OS_SendMessage(subtask1_id,MSG_ID_FOTA_DINIT_CONF,0, 0);		// if(ret <0)		// {			// APP_DEBUG("\r\n<--failed!!, Ql_OS_SendMessage(1, %d, %d) fail,  ret=%d-->\r\n", 0, 0, ret);		// }		// APP_DEBUG("\r\n<--Ql_OS_SendMessage(%d, %d, %d) ret=%d-->\r\n",MSG_ID_USER_DATA,0, 0, ret);		//Ql_UART_ClrRxBuffer(UART_PORT1);				Ql_UART_Close(UART_PORT3);		Ql_UART_ClrRxBuffer(UART_PORT3);		ST_GprsConfig apnCfg;		Ql_memcpy(apnCfg.apnName,   APN_NAME, Ql_strlen(APN_NAME));		Ql_memcpy(apnCfg.apnUserId, APN_USERID, Ql_strlen(APN_USERID));		Ql_memcpy(apnCfg.apnPasswd, APN_PASSWD, Ql_strlen(APN_PASSWD));		Ql_memset(m_URL_Buffer, 0, URL_LEN);				//http://hostname:port/filePath/fileName		//Ql_sprintf(m_URL_Buffer, "%s%s",APP_BIN_URL,m_Read_Buffer_fota);		//APP_DEBUG("\r\n<-- URL:%s-->\r\n",m_URL_Buffer);				//Ql_FOTA_StartUpgrade(APP_BIN_URL, &apnCfg, NULL);		//break;		//}}void MODBUS_WRITE_QUERIES(){	s32 ret;	if(MODBUS_WRITE_FLAG == 1)	{		APP_DEBUG("\r\enter mod write\r\n");		//MODBUS_WRITE_FLAG = 0;		APP_DEBUG("\r\MODBUS_WRITE_QURIES_COUNT = %d\r\n", MODBUS_WRITE_QURIES_COUNT);		//SEPARATE_MODBUS_DATA(MODBUS_WRITE_QURIES_COUNT,database);		if(MODBUS_WRITE_QURIES_COUNT > 0)		{			MODBUS_WRITE_QURIES_COUNT--;			APP_DEBUG("\r\n data = %d, address = %d \r\n", data_mod[MODBUS_WRITE_QURIES_COUNT],address_mod[MODBUS_WRITE_QURIES_COUNT] );			CALCULATE_CRC(address_mod[MODBUS_WRITE_QURIES_COUNT], data_mod[MODBUS_WRITE_QURIES_COUNT]);		}		else		{			ret = Ql_Timer_Stop(Stack_timer4);			if(ret < 0)			{				  APP_DEBUG("\r\n<--failed!! stack timer Ql_Timer_Stop3 ret=%d-->\r\n",ret);           			}			APP_DEBUG("\r\n<--stack timer Ql_Timer_Stop3(ID=%d,) ret=%d-->\r\n",Stack_timer3,ret); 		}		APP_DEBUG("\r\exit mod write\r\n");	}	}void MODBUS_READ_QURIES(){		if(send_flag1 == 1)	{		if(send_flag2 == 1)		{			s32 ret;			char Query_Status_Flag = 1;			if(QUERY_POINTER > 0)			{				if(DATA_RCV_ON_UART_FOR_MODBUS_FLAG == 1)				{					DATA_RCV_ON_UART_FOR_MODBUS_FLAG = 0;					//QUERY_REPEAT_COUNTER = 0;				}				else				{					//QUERY_REPEAT_COUNTER++;					//if(QUERY_REPEAT_COUNTER > (QUERY_REPEAT_COUNT - 1))					{						char buffer[10];												//QUERY_REPEAT_COUNTER = 0;												if((FUNCTION_CODE[QUERY_POINTER - 1] == 0x01) || (FUNCTION_CODE[QUERY_POINTER - 1] == 0x02))						{							char temp_length, temp_length_1;														temp_length = MODBUS_LEGTH[QUERY_POINTER - 1];							temp_length_1 = temp_length / 8;														if((temp_length % 8) == 0)							{}							else							{								temp_length_1++;  							}						//	APP_DEBUG("<-- APP_DEBUG 1\r\n");							CAPTURE_DATA_FOR_PAYLOAD(buffer, temp_length_1, NO_COMM_DATA);						}						else if((FUNCTION_CODE[QUERY_POINTER - 1] == 0x03) || (FUNCTION_CODE[QUERY_POINTER - 1] == 0x04))						{							char temp_length, temp_length_1;														temp_length = MODBUS_LEGTH[QUERY_POINTER - 1];							temp_length_1 = temp_length * 2;						//  APP_DEBUG("<-- APP_DEBUG 2\r\n");							CAPTURE_DATA_FOR_PAYLOAD(buffer, temp_length_1, NO_COMM_DATA);						}					}					//else					//{Query_Status_Flag = 0; }				}			}       						if(Query_Status_Flag)			{				CREATE_AND_SEND_MODBUS_DATA(MODBUS_SLAVE_ID_BUFF[QUERY_POINTER], FUNCTION_CODE[QUERY_POINTER], MODBUS_ADDRESS[QUERY_POINTER], MODBUS_LEGTH[QUERY_POINTER]);				//APP_DEBUG("<-- PREVIOUS QUERY_POINTER = %d\r\n", QUERY_POINTER);							if(QUERY_POINTER == 0)				{						QUERY_RCV_POINTER = 0;					QUERY_POINTER++;				}				else				{					QUERY_POINTER++;					QUERY_RCV_POINTER++;				}								// if((Slave_1_QN==QUERY_POINTER) || (Slave_2_QN==QUERY_POINTER) || (Slave_3_QN==QUERY_POINTER) || (Slave_4_QN==QUERY_POINTER))				// {					// Flag=1;				// }                  09-05-23								APP_DEBUG("\r\n");				APP_DEBUG("<----- QUERY NO. %d Sent ----->\r\n", QUERY_POINTER);			//	APP_DEBUG("\r\n");								if(QUERY_POINTER >= NO_OF_QUERY)				{					QUERY_POINTER = 0;					send_flag1 = 0;				}				//APP_DEBUG("<-- QUERY_POINTER_SEND = %d\r\n", QUERY_POINTER);				//APP_DEBUG("<-- QUERY_POINTER_RCV = %d\r\n", QUERY_RCV_POINTER);				//APP_DEBUG("<-- END OF MODBUS READ QURIES FUNCTION\r\n");			}			else			{				CREATE_AND_SEND_MODBUS_DATA(MODBUS_SLAVE_ID_BUFF[QUERY_POINTER - 1], FUNCTION_CODE[QUERY_POINTER - 1], MODBUS_ADDRESS[QUERY_POINTER - 1], MODBUS_LEGTH[QUERY_POINTER - 1]);			}						ret = Ql_Timer_Start(Stack_timer2,ST_Interval_2,FALSE);			if(ret < 0)			{				//APP_DEBUG("<--failed!! GP-timer Ql_Timer_Start fail, ret=%d-->\r\n",ret);			}                			//APP_DEBUG("<--MODBUS QUERY DELAY TIMER Start(ID=%d,Interval=%d) ret=%d-->\r\n",Stack_timer2,ST_Interval_2,ret);		}	}	else	{		//APP_DEBUG("\r\n LAST QUERY TIMER\r\n");		if(DATA_RCV_ON_UART_FOR_MODBUS_FLAG == 1)		{			DATA_RCV_ON_UART_FOR_MODBUS_FLAG = 0;		}		else		{			char buffer[10];			if((FUNCTION_CODE[NO_OF_QUERY - 1] == 0x01) || (FUNCTION_CODE[NO_OF_QUERY - 1] == 0x02))			{				char temp_length, temp_length_1;								temp_length = MODBUS_LEGTH[NO_OF_QUERY - 1];				temp_length_1 = temp_length / 8;								if((temp_length % 8) == 0)				{}				else				{					temp_length_1++;				}			//	APP_DEBUG("<-- APP_DEBUG 3\r\n");				CAPTURE_DATA_FOR_PAYLOAD(buffer, temp_length_1, NO_COMM_DATA);			}			else if((FUNCTION_CODE[NO_OF_QUERY - 1] == 0x03) || (FUNCTION_CODE[NO_OF_QUERY - 1] == 0x04))			{				char temp_length, temp_length_1;								temp_length = MODBUS_LEGTH[NO_OF_QUERY - 1];				temp_length_1 = temp_length * 2;			//	APP_DEBUG("<-- APP_DEBUG 4\r\n"); line no 2417 send_flag=0				CAPTURE_DATA_FOR_PAYLOAD(buffer, temp_length_1, NO_COMM_DATA); 			}		}	}}static void Callback_UART_Hdlr_Main_Port(Enum_SerialPort port, Enum_UARTEventType msg, bool level, void* customizedPara){    u32 rdLen=0;	int i;	char my_char[1024]={0};	s32 ret;	bool setting_flag = 0;    char *q=NULL,*p=NULL;		if(m_myVirtualPort == port)     {        switch (msg)        {            case EVENT_UART_READY_TO_READ:            {                Ql_memset(m_Read_Buffer, 0x0, sizeof(m_Read_Buffer));                rdLen = Ql_UART_Read(port, m_Read_Buffer, sizeof(m_Read_Buffer));                //APP_DEBUG("\r\nmodem data =%s\r\n",m_Read_Buffer);                      break;            }            default:            break;        }    }    else if( UART_PORT1 == port | UART_PORT2 == port | UART_PORT3 == port)    {        switch (msg)        {            case EVENT_UART_READY_TO_READ:            {					Ql_memset(m_Read_Buffer, 0x0, sizeof(m_Read_Buffer));                rdLen = Ql_UART_Read(port, m_Read_Buffer, sizeof(m_Read_Buffer));								APP_DEBUG("\r\DATA LENGTH = %d\r\n",rdLen);      				APP_DEBUG("\r\DATA RECIEVED: %s\r\n",m_Read_Buffer);  				p = Ql_strstr(m_Read_Buffer,"SEND MSG");				if(p)				{					SEND_SMS(1,"MODULE SMS\0","+918087850993\0");				}								p = Ql_strstr(m_Read_Buffer,"SEND DATA TO PORT3");				if(p)				{					Ql_UART_Write(UART_PORT3, m_Read_Buffer, rdLen);				}								p = Ql_strstr(m_Read_Buffer,"*SEND SMS TO NO:");				if(p)				{					p = p + 16; 					char temp_no[15];										Ql_memset(temp_no, 0, sizeof(temp_no));										for(i=0; i<13; i++)					{						temp_no[i] = *(p + i);					}					APP_DEBUG("<-- RCV NO: %s",temp_no);					if(*(p + i) == '#')					{						SEND_SMS(1,"MODULE SMS\0",temp_no);					}					else					{						APP_DEBUG("<-- WRONG MSG PLEASE CHECK END OF THE STRING\r\n");					}				}							/*	p = Ql_strstr(m_Read_Buffer,"SEND MQTT DATA:");				if(p)				{					p= p+ 15;					char temp_buff[100], i;					Ql_memset(temp_buff, 0, sizeof(temp_buff));					i=0;						while(*p != 0)					{						temp_buff[i] = *p;						p++;						i++;					}					temp_buff[i] = 0;										pub_message_id++;  // The range is 0-65535. It will be 0 only when<qos>=0.					ret = RIL_MQTT_QMTPUB(connect_id,pub_message_id,QOS1_AT_LEASET_ONCE,0,test_topic,i,temp_buff);					if (RIL_AT_SUCCESS == ret)					{						APP_DEBUG("//<Start publish a message to server\r\n");					}else					{						APP_DEBUG("<-- Publish a message to server failure -->\r\n");					}									}    								p = Ql_strstr(m_Read_Buffer,"SEND MQTT DATA1:");				if(p)				{					p= p+ 16;					char temp_buff[100], i;					Ql_memset(temp_buff, 0, sizeof(temp_buff));					i=0;						while(*p != 0)					{						temp_buff[i] = *p;						p++;						i++;					}					temp_buff[i] = 0;										pub_message_id++;  // The range is 0-65535. It will be 0 only when<qos>=0.					ret = RIL_MQTT_QMTPUB(connect_id,pub_message_id,QOS1_AT_LEASET_ONCE,0,test_topic_PUB_array[0],i,temp_buff);					if (RIL_AT_SUCCESS == ret)					{						APP_DEBUG("//<Start publish a message to server\r\n");					}else					{						APP_DEBUG("<-- Publish a message to server failure -->\r\n");					}									}   */								if(m_Read_Buffer[0] == '$')				{					setting_flag = 1;//configuration message is start with '$' symbol , if this symobl is presrnt allow message to enter in configuration code.				}								if(setting_flag == 1)// Device ID setting and Status checking same as SMS module				{					setting_flag = 0;					bool Reset_Contoller_Flag = 0;										q = Ql_strstr(m_Read_Buffer,"CVID#");					if(q)					{						u8 device_id_rcv1[15]="";						int i=0;												APP_DEBUG("\r\nenter\r\n");						for(i = 0 ; i < 8; i++)						{							device_id_rcv1[i] = m_Read_Buffer[6 + i];							}						device_id_rcv1[i] = '\0';							if(m_Read_Buffer[6 + i] == '#')						{							for(i=0; i<15; i++) 							{								if((device_id_rcv1[i] >= 48) && (device_id_rcv1[i] <= 57))  // 48 is an ASCII value of 0 and 57 is an ASCII value of 9								{									DEVICE_ID[i] = device_id_rcv1[i] ;								}								else{//APP_DEBUG("Invalid Device ID\r\n");								}								if(device_id_rcv1[i] == '\0'){break;}							}							APP_DEBUG("<---DEVICE ID: %s --->\r\n",DEVICE_ID);							WRITE_DATA_TO_UFS(4, DEVICE_ID);						}						else						{							APP_DEBUG("<-- LENGTH OF THE ID IS WRONG, LENGTH MUST BE 8 -->\r\n");						}							}					else					{						APP_DEBUG("<-- Not Enter In ID Session  -->\r\n");					}										q = Ql_strstr(m_Read_Buffer,"CGPR#");					if(q)					{						u8 apn_rcv[30]="",j;												for(i = 0 ; i < 30; i++)						{							if(m_Read_Buffer[6 + i] == '#')							{										break;							}							else							{										apn_rcv[i] = m_Read_Buffer[6 + i];								}						}						apn_rcv[i] = '\0';							if(i > 25)						{									APP_DEBUG("<-- WRONG SMS APN LENGTH IS GREATER THAN '25' -->\r\n");							}						else if(i == 0)						{									APP_DEBUG("<-- WRONG SMS APN LENGTH IS EQUAL TO 'ZERO' -->\r\n");							}						else						{							for(j=0 ; j < i ;j++)							{								APN_NAME[j] = apn_rcv[j];							}							APN_NAME[j] = '\0';														WRITE_DATA_TO_UFS(5, apn_rcv);								APP_DEBUG("<-- APN VALID STORED IN MEMORY -->\r\n");							//Ql_Reset(0);							Reset_Contoller_Flag = 1;						}						APP_DEBUG("\r\n<-- DEVICE APN => %s -->\r\n",APN_NAME);						}						else					{						APP_DEBUG("<-- Not Enter In APN Session  -->\r\n");					}										q = Ql_strstr(m_Read_Buffer,"$GCON#");					if(q)					{						char msg_1[200];						Ql_memset(msg_1, 0, 200);						Ql_sprintf(msg_1,"VERSION-%s, Model=%s, ID=%s, APN=%s, Config Topic name=%s, Publish Topic name=%s, Broker name = torlenzmqtt.remotemonitor.in\0",VERSION,MODEL_NAME,DEVICE_ID,APN_NAME,test_topic_SUB_array[0],test_topic_PUB_array[0]);							APP_DEBUG("<-- %s -->\r\n", msg_1);					}									/*	q = Ql_strstr(m_Read_Buffer,"$GHTTPURL#");					if(q)					{						char msg_1[200];						Ql_memset(msg_1, 0, 200);						Ql_sprintf(msg_1,"VERSION-%s,HTTP_URL_ADDR=%s\0",VERSION,HTTP_URL_ADDR );							APP_DEBUG("<-- %s -->\r\n", msg_1);					}*/										p = Ql_strstr(m_Read_Buffer,"$PROJECT_NAME#");					if(p)					{						char msg_1[200];						Ql_memset(msg_1, 0, 200);						Ql_sprintf(msg_1,"PROJECT NAME: %s\0",MODEL_NAME);						APP_DEBUG("<-- %s -->\r\n",msg_1);					}										p = Ql_strstr(m_Read_Buffer,"$GSER-MOD#");					if(p)					{						char msg_1[200];						Ql_memset(msg_1, 0, 200);						Ql_sprintf(msg_1,"VERSION-%s \nID=%s \nSLAVE ID=%d \nBAUDRATE = %ld \nDATABITS = %d, \nSTOPBITS = %d \nPARITYBITS = %d \nFLOWCTRL = %d\0",VERSION, DEVICE_ID, MODBUS_SLAVE_ID, port2_dcb.baudrate, port2_dcb.dataBits, port2_dcb.stopBits,	port2_dcb.parity, port2_dcb.flowCtrl);						APP_DEBUG("\r\n<-----------------------------");						APP_DEBUG("\r\n<-----------------------------");						APP_DEBUG("\r\n<-----------------------------");						APP_DEBUG("\r\n<--\r\n%s \r\n-->\r\n", msg_1);						APP_DEBUG("----------------------------->\r\n");						APP_DEBUG("----------------------------->\r\n");						APP_DEBUG("----------------------------->\r\n");					}										p = Ql_strstr(m_Read_Buffer,"CON#MODADD#");					if(p)					{						if(m_Read_Buffer[rdLen - 1] == '<')						{							char No_Of_Queries;														p = p + 11;														No_Of_Queries = ((*p - 48) * 10) + (*(p+1) - 48);														APP_DEBUG("<------------------------------------------------------\r\n");							APP_DEBUG("<------------------------------------------------------\r\n");							APP_DEBUG("<-- No_Of_Queries = %d\r\n", No_Of_Queries);														if(No_Of_Queries > 99)							{								APP_DEBUG("\r\n*CON#MODBUS#ERROR#03#\r\n");							}							else if(rdLen != ((No_Of_Queries * 16) + 16))							{								APP_DEBUG("\r\n*CON#MODBUS#ERROR#02#\r\n");							}							else							{								char i;								p = p + 3;																APP_DEBUG("\r\n\r\n\r\n");																for(i=0; i<No_Of_Queries; i++)								{									MODBUS_SLAVE_ID_BUFF[i] = (((p[0] - 48) * 100) + ((p[1] - 48) * 10) + (p[2] - 48)); 																		FUNCTION_CODE[i] = (p[4] - 48);																		MODBUS_ADDRESS[i] = (((p[6] - 48) * 10000) + ((p[7] - 48) * 1000) + ((p[8] - 48) * 100) + ((p[9] - 48) * 10) + ((p[10] - 48)));   									MODBUS_LEGTH[i] = (((p[12] - 48) * 100) + ((p[13] - 48) * 10) + (p[14] - 48));																		p = p + 16;																		APP_DEBUG("<--- POSITION %02d: MODBUS_SLAVE_ID = %03d, FUNCTION_CODE = %d, MODBUS_ADDRESS = %05d, MODBUS_LEGTH = %03d\r\n",i, MODBUS_SLAVE_ID_BUFF[i], FUNCTION_CODE[i], MODBUS_ADDRESS[i], MODBUS_LEGTH[i]);								}								NO_OF_QUERY = No_Of_Queries;									APP_DEBUG("<------------------------------------------------------\r\n");								APP_DEBUG("<------------------------------------------------------\r\n");								APP_DEBUG("\r\n*CON#MODBUS#VALID#\r\n");								WRITE_DATA_TO_UFS(3, m_Read_Buffer);							}						}						else						{							APP_DEBUG("\r\n*CON#MODBUS#ERROR#01#\r\n");						}					}										p = Ql_strstr(m_Read_Buffer,"GET#MODADD#");					if(p)					{						char i=0;						APP_DEBUG("<------------------------------------------------------\r\n");						APP_DEBUG("<------------------------------------------------------\r\n");						APP_DEBUG("<-- MODBUS ADDRESS SET CONFIGURATION\r\n");												APP_DEBUG("<-- NO OF QUERIES = %02d\r\n", NO_OF_QUERY);						APP_DEBUG("\r\n\n");						APP_DEBUG("<-- MODBUS ADDRESS SET\r\n");												for(i=0; i<NO_OF_QUERY; i++)						{							APP_DEBUG("<--- POSITION %02d: MODBUS_SLAVE_ID = %03d, FUNCTION_CODE = %d, MODBUS_ADDRESS = %05d, MODBUS_LEGTH = %03d\r\n",i, MODBUS_SLAVE_ID_BUFF[i], FUNCTION_CODE[i], MODBUS_ADDRESS[i], MODBUS_LEGTH[i]);						}						APP_DEBUG("<------------------------------------------------------\r\n");						APP_DEBUG("<------------------------------------------------------\r\n");					}										p = Ql_strstr(m_Read_Buffer,"SLAVE-ID#");					if(p)					{						char temp_slave_id[6];						p = p + 9;												for(i=0; i<3; i++)						{							temp_slave_id[i] = p[i];						}												temp_slave_id[i] = 0;												if(p[i] == '#')						{							APP_DEBUG("<-- LENGTH IS MATCH\r\n");							if((temp_slave_id[0] < 48) || (temp_slave_id[0] > 57) || (temp_slave_id[1] < 48) || (temp_slave_id[1] > 57) || (temp_slave_id[2] < 48) || (temp_slave_id[2] > 57))							{ 								APP_DEBUG("<-- SLAVE ID DIGIT NOT BETWEEN 0-9\r\n");							}							else							{								char slave_id=0;																slave_id = ((temp_slave_id[0] - 48) * 100) + ((temp_slave_id[1] - 48) * 10) + (temp_slave_id[2] - 48);  																APP_DEBUG("<-- TEMP_SLAVE_ID = %d", slave_id);																if(slave_id > 250)								{									APP_DEBUG("<-- SLAVE_ID IS GREATER THAN 250\r\n"); 								}								else								{									char Stored_Array[150];																		Ql_memset(Stored_Array, 0, sizeof(Stored_Array));																		MODBUS_SLAVE_ID = slave_id;									APP_DEBUG("<-- MODBUS_SLAVE_ID = %d", MODBUS_SLAVE_ID);																	//	Ql_sprintf(Stored_Array,"VERSION-%s, ID=%s, SLAVE ID_1=%03d, SLAVE ID_2=%03d, SLAVE ID_3=%03d, SLAVE ID_4=%03d, BAUDRATE = %ld, PARITYBITS = %d\0",VERSION, DEVICE_ID, MODBUS_SLAVE[0], MODBUS_SLAVE[1], MODBUS_SLAVE[2], MODBUS_SLAVE[3], port2_dcb.baudrate, port2_dcb.parity);												WRITE_DATA_TO_UFS(1, Stored_Array);								}							}						}						else{APP_DEBUG("<-- LENGTH IS NOT MATCH IT SHOULD NOT CROSS 3 DIGIT OR LESS THAN 3 DIGIT\r\n");}						}									p = Ql_strstr(m_Read_Buffer,"BAUDRATE#");					if(p)					{						char *r=NULL;						bool baudrate_valid_flag = 0;						u32 temp_baudrate=0;												r = Ql_strstr(m_Read_Buffer,"4800");						if(r)						{							baudrate_valid_flag = 1;							temp_baudrate = (((r[0] - 48) * 1000) +  ((r[1] - 48) * 100) + ((r[2] - 48) * 10) + (r[3] - 48));														APP_DEBUG("<-- BAUDRATE SESSION 4800 RCV BAUDRATE => %ld", temp_baudrate);						}												r = Ql_strstr(m_Read_Buffer,"9600");						if(r)						{							baudrate_valid_flag = 1;							temp_baudrate = (((r[0] - 48) * 1000) +  ((r[1] - 48) * 100) + ((r[2] - 48) * 10) + (r[3] - 48));														APP_DEBUG("<-- BAUDRATE SESSION 9600 RCV BAUDRATE => %ld", temp_baudrate);						}												r = Ql_strstr(m_Read_Buffer,"19200");						if(r)						{							baudrate_valid_flag = 1;							temp_baudrate = (((r[0] - 48) * 10000) +  ((r[1] - 48) * 1000) + ((r[2] - 48) * 100) + ((r[3] - 48) * 10) + (r[4] - 48));														APP_DEBUG("<-- BAUDRATE SESSION 19200 RCV BAUDRATE => %ld", temp_baudrate);						}												r = Ql_strstr(m_Read_Buffer,"38400");						if(r)						{							baudrate_valid_flag = 1;							temp_baudrate = (((r[0] - 48) * 10000) +  ((r[1] - 48) * 1000) + ((r[2] - 48) * 100) + ((r[3] - 48) * 10) + (r[4] - 48));														APP_DEBUG("<-- BAUDRATE SESSION 38400 RCV BAUDRATE => %ld", temp_baudrate);						}												r = Ql_strstr(m_Read_Buffer,"57600");						if(r)						{							baudrate_valid_flag = 1;							temp_baudrate = (((r[0] - 48) * 10000) +  ((r[1] - 48) * 1000) + ((r[2] - 48) * 100) + ((r[3] - 48) * 10) + (r[4] - 48));														APP_DEBUG("<-- BAUDRATE SESSION 57600 RCV BAUDRATE => %ld", temp_baudrate);						}												r = Ql_strstr(m_Read_Buffer,"115200");						if(r)						{							baudrate_valid_flag = 1;							temp_baudrate = (((r[0] - 48) * 100000) +  ((r[1] - 48) * 10000) + ((r[2] - 48) * 1000) + ((r[3] - 48) * 100) + ((r[4] - 48) * 100) + (r[5] - 48));														APP_DEBUG("<-- BAUDRATE SESSION 115200 RCV BAUDRATE => %ld", temp_baudrate);						}												if(baudrate_valid_flag == 1)						{							if(m_Read_Buffer[rdLen - 1] == '#')							{								char Stored_Array[150];																port2_dcb.baudrate = temp_baudrate;								APP_DEBUG("<-- port2_dcb.baudrate: %ld", port2_dcb.baudrate);																Ql_sprintf(Stored_Array,"SLAVE-ID:%03d,BAUDRATE:%06d,PARITY:%d,PROJ-NAME:%s,\0", MODBUS_SLAVE_ID, port2_dcb.baudrate, port2_dcb.parity, MODEL_NAME);											WRITE_DATA_TO_UFS(1, Stored_Array);															//Ql_Reset(1000);								Reset_Contoller_Flag = 1;							}							else{APP_DEBUG("<-- END OF THE MSG NOT MATCH\r\n");}						}						else{APP_DEBUG("<-- BAUDRATE INVALID\r\n");}					}										p = Ql_strstr(m_Read_Buffer,"PARITY#");					if(p)					{ 						char *r=NULL;						bool parity_valid_flag = 0;						char temp_parity=0;												r = Ql_strstr(m_Read_Buffer,"NONE");						if(r)						{							parity_valid_flag = 1;							temp_parity = 0;														APP_DEBUG("<-- PRITY SESSION NONE RCV PARITY=> %d", temp_parity);						}												r = Ql_strstr(m_Read_Buffer,"ODD");						if(r)						{							parity_valid_flag = 1;							temp_parity = 1;														APP_DEBUG("<-- PRITY SESSION ODD RCV PARITY=> %d", temp_parity);						}												r = Ql_strstr(m_Read_Buffer,"EVEN");						if(r)						{							parity_valid_flag = 1;							temp_parity = 2;														APP_DEBUG("<-- PRITY SESSION EVEN RCV PARITY=> %d", temp_parity);						}												if(parity_valid_flag == 1)						{							if(m_Read_Buffer[rdLen - 1] == '#')							{								char Stored_Array[150];																port2_dcb.parity = temp_parity;								APP_DEBUG("<-- port2_dcb.parity: %ld", port2_dcb.parity);																Ql_sprintf(Stored_Array,"SLAVE-ID:%03d,BAUDRATE:%06d,PARITY:%d,PROJ-NAME:%s,\0", MODBUS_SLAVE_ID, port2_dcb.baudrate, port2_dcb.parity, MODEL_NAME);											WRITE_DATA_TO_UFS(1, Stored_Array);															//Ql_Reset(1000);								Reset_Contoller_Flag = 1;							}							else{APP_DEBUG("<-- END OF THE MSG NOT MATCH\r\n");}						}						else{APP_DEBUG("<-- PARITY INVALID\r\n");}					}										p = Ql_strstr(m_Read_Buffer,"PROJ-NAME#");					if(p)					{						char Project_Name[30], i;												Ql_memset(Project_Name, 0, sizeof(Project_Name));						p = p + 10;												for(i=0; i<27; i++)						{							if(p[i] == '#')							{								break;							}										Project_Name[i] = p[i];						}						Project_Name[i] = 0;												if(i >= 26)						{							APP_DEBUG("<--- END OF THE STRING IS MUST BE '#', AND LENGTH OF STRING MUST BE LESS THAN '25'\r\n");						}						else if(i == 0)						{							APP_DEBUG("<--- NO NAME RCV IN STRING\r\n");						}						else						{							char j=0;							char Stored_Array[150];							Ql_memset(MODEL_NAME, 0 , sizeof(MODEL_NAME));														for(j=0; j<i; j++)							{								MODEL_NAME[j] = Project_Name[j];							}														Ql_sprintf(Stored_Array,"SLAVE-ID:%03d,BAUDRATE:%06d,PARITY:%d,PROJ-NAME:%s,\0", MODBUS_SLAVE_ID, port2_dcb.baudrate, port2_dcb.parity, MODEL_NAME);										WRITE_DATA_TO_UFS(1, Stored_Array);							}					}										p = Ql_strstr(m_Read_Buffer,"DURL#");					if(p)					{						char i, http_url[200];						p = p + 5;												for(i=0; i<160; i++)						{							if(*p == '#')							{break;}							http_url[i] = *p;							p = p + 1;						}												if(i == 0)						{							APP_DEBUG("<-- NO DATA IS PRESENT IN SMS\r\n");						}						else if(i >= 150)						{							APP_DEBUG("<-- URL LENGTH CROSS 150\r\n");						}						else						{							char Stored_Array[200];							APP_DEBUG("<-- VALID URL\r\n");														Ql_memset(Stored_Array, 0, sizeof(Stored_Array));							Ql_sprintf(Stored_Array,"HTTP_URL=%s\0",http_url);							WRITE_DATA_TO_UFS(14, Stored_Array);							APP_DEBUG("%s\r\n",Stored_Array);							//Ql_Reset(1000);							Reset_Contoller_Flag = 1;						}					}					if(Reset_Contoller_Flag == 1)					{						Reset_Contoller_Flag = 0;						Ql_Reset(1000);					}				}	            } 			break;		 	            default:                break;         }    }}static void Callback_UART_Hdlr_Modbus_Port(Enum_SerialPort port, Enum_UARTEventType msg, bool level, void* customizedPara){    u32 rdLen=0;	int i, k,lenn;	char my_char[1024]={0};	s32 ret;			bool setting_flag = 0;    char *q=NULL;	switch (msg)    {		case EVENT_UART_READY_TO_READ:        {         			Ql_memset(m_Read_Buffer, 0x0, sizeof(m_Read_Buffer));			rdLen = Ql_UART_Read(port, m_Read_Buffer, sizeof(m_Read_Buffer));					//	APP_DEBUG("<-- PORT 2 SERIAL DATA: %s\r\n",m_Read_Buffer);		//	APP_DEBUG("<--LENGTH: %d\n\n",rdLen);      			if((UART_PORT2 == port) && (PORT2_COMMUNICATION_FLAG == 1))			{				if((rdLen <= 8) && (rdLen != 7) && (rdLen != 6))				{				//	APP_DEBUG("<-- DATA LENGTH IS LESS THAN OR EQUAL TO 8\r\n");   										Ql_memset(my_char,0,sizeof(my_char));					for(i = 0; i< (rdLen); i++)//convert hex data to ascii form					{						k= i*2;						my_char[k] = DECIMAL_TO_HEX(m_Read_Buffer[i] / 0x10);						my_char[k+1] = DECIMAL_TO_HEX(m_Read_Buffer[i] % 0x10);					}					//APP_DEBUG("DATA IN HEX => %s\r\n",my_char);					break;				}				DATA_RCV_ON_UART_FOR_MODBUS_FLAG = 1;				if(CHECK_MODBUS_QUERY_RESPONSE_FLAG == 1)				{					CHECK_MODBUS_QUERY_RESPONSE_FLAG = 0;					MODBUS_RESPONSE_CHECK(m_Read_Buffer, rdLen);				}else{APP_DEBUG("<-- CHECK_MODBUS_QUERY_RESPONSE_FLAG IS ZERO\r\n");}			}		}	}}static void Callback_UART_Hdlr_ETHERNET_PORT(Enum_SerialPort port, Enum_UARTEventType msg, bool level, void* customizedPara){    APP_DEBUG("CallBack_UART_Hdlr: port=%d, event=%d, level=%d, p=%x\r\n", port, msg, level, customizedPara);    u32 rdLen=0;	int i, k,lenn;	char my_char[1024]={0};	s32 ret;	bool setting_flag = 0;	char *q=NULL, *p=NULL;	    if( UART_PORT1 == port | UART_PORT2 == port | UART_PORT3 == port)    {        switch (msg)        {            case EVENT_UART_READY_TO_READ:            {                Ql_memset(m_Read_Buffer, 0x0, sizeof(m_Read_Buffer));                rdLen = Ql_UART_Read(port, m_Read_Buffer, sizeof(m_Read_Buffer));								APP_DEBUG("<-- DATA LENGTH RCV ON PORT-3: %d\r\n",rdLen);      				APP_DEBUG("<-- DATA RCV ON PORT-3: %s\r\n",m_Read_Buffer);  								//q = Ql_strstr(m_Read_Buffer,"YES");			}		}	}}static void Hdlr_RecvNewSMS(u32 nIndex, bool bAutoReply){	s32 iResult = 0,length1 = 0, i=0, j =0 , SMS_Length;	u32 uMsgRef = 0;	u8 device_id_rcv[15]="";	u8 apn_rcv[30]="";	u8 ip_rcv[15]="";	u8 ip_rcv2[15]="";	u8 port_rcv[7]="";	u8 port_rcv2[7]="";	u8 time_rcv[7]="";	u8 time1_rcv[7]="";	u32 writenLen = 0;	u32 readenLen = 0;	s32 position = 0;    	s32 handle = -1;	u8  writeBuffer[LENGTH];	u8 strBuf[LENGTH] = {0};	char *p=NULL, *q=NULL, *p1=NULL;	u8 msg_buffer[50] = "",ret;	ST_RIL_SMS_TextInfo *pTextInfo = NULL;	ST_RIL_SMS_DeliverParam *pDeliverTextInfo = NULL;	char aPhNum[RIL_SMS_PHONE_NUMBER_MAX_LEN] = {+918087850993};	char aReplyCon[1000];	bool bResult = FALSE;     	Ql_memset(aReplyCon, 0x00, sizeof(aReplyCon));	    pTextInfo = Ql_MEM_Alloc(sizeof(ST_RIL_SMS_TextInfo));    if (NULL == pTextInfo)    {        APP_DEBUG("%s/%d:Ql_MEM_Alloc FAIL! size:%u\r\n", sizeof(ST_RIL_SMS_TextInfo), __func__, __LINE__);        return;    }    Ql_memset(pTextInfo, 0x00, sizeof(ST_RIL_SMS_TextInfo));    iResult = RIL_SMS_ReadSMS_Text(nIndex, LIB_SMS_CHARSET_GSM, pTextInfo);    if (iResult != RIL_AT_SUCCESS)    {        Ql_MEM_Free(pTextInfo);        APP_DEBUG("Fail to read text SMS[%d], cause:%d\r\n", nIndex, iResult);        return;    }                if ((LIB_SMS_PDU_TYPE_DELIVER != (pTextInfo->type)) || (RIL_SMS_STATUS_TYPE_INVALID == (pTextInfo->status)))    {        Ql_MEM_Free(pTextInfo);        APP_DEBUG("WARNING: NOT a new received SMS.\r\n");            return;    }        pDeliverTextInfo = &((pTextInfo->param).deliverParam);        if(TRUE == pDeliverTextInfo->conPres)  //Receive CON-SMS segment    {        s8 iBufIdx = 0;        u8 uSeg = 0;        u16 uConLen = 0;        iBufIdx = ConSMSBuf_GetIndex(g_asConSMSBuf,CON_SMS_BUF_MAX_CNT,&(pDeliverTextInfo->con));        if(-1 == iBufIdx)        {            APP_DEBUG("Enter Hdlr_RecvNewSMS,WARNING! ConSMSBuf_GetIndex FAIL! Show this CON-SMS-SEG directly!\r\n");            APP_DEBUG(                "status:%u,type:%u,alpha:%u,sca:%s,oa:%s,scts:%s,data length:%u,cp:1,cy:%d,cr:%d,ct:%d,cs:%d\r\n",                    (pTextInfo->status),                    (pTextInfo->type),                    (pDeliverTextInfo->alpha),                    (pTextInfo->sca),                    (pDeliverTextInfo->oa),                    (pDeliverTextInfo->scts),                    (pDeliverTextInfo->length),                    pDeliverTextInfo->con.msgType,                    pDeliverTextInfo->con.msgRef,                    pDeliverTextInfo->con.msgTot,                    pDeliverTextInfo->con.msgSeg            );            APP_DEBUG("data = %s\r\n",(pDeliverTextInfo->data));            Ql_MEM_Free(pTextInfo);                    return;        }        bResult = ConSMSBuf_AddSeg(                    g_asConSMSBuf,                    CON_SMS_BUF_MAX_CNT,                    iBufIdx,                    &(pDeliverTextInfo->con),                    (pDeliverTextInfo->data),                    (pDeliverTextInfo->length)        );        if(FALSE == bResult)        {            APP_DEBUG("Enter Hdlr_RecvNewSMS,WARNING! ConSMSBuf_AddSeg FAIL! Show this CON-SMS-SEG directly!\r\n");            APP_DEBUG(                "status:%u,type:%u,alpha:%u,sca:%s,oa:%s,scts:%s,data length:%u,cp:1,cy:%d,cr:%d,ct:%d,cs:%d\r\n",                (pTextInfo->status),                (pTextInfo->type),                (pDeliverTextInfo->alpha),                (pTextInfo->sca),                (pDeliverTextInfo->oa),                (pDeliverTextInfo->scts),                (pDeliverTextInfo->length),                pDeliverTextInfo->con.msgType,                pDeliverTextInfo->con.msgRef,                pDeliverTextInfo->con.msgTot,                pDeliverTextInfo->con.msgSeg            );            APP_DEBUG("data = %s\r\n",(pDeliverTextInfo->data));            Ql_MEM_Free(pTextInfo);                    return;        }        bResult = ConSMSBuf_IsIntact(                    g_asConSMSBuf,                    CON_SMS_BUF_MAX_CNT,                    iBufIdx,                    &(pDeliverTextInfo->con)        );        if(FALSE == bResult)        {            APP_DEBUG(                "Enter Hdlr_RecvNewSMS,WARNING! ConSMSBuf_IsIntact FAIL! Waiting. cp:1,cy:%d,cr:%d,ct:%d,cs:%d\r\n",                pDeliverTextInfo->con.msgType,                pDeliverTextInfo->con.msgRef,                pDeliverTextInfo->con.msgTot,                pDeliverTextInfo->con.msgSeg            );            Ql_MEM_Free(pTextInfo);            return;        }        //Show the CON-SMS        APP_DEBUG(            "status:%u,type:%u,alpha:%u,sca:%s,oa:%s,scts:%s",            (pTextInfo->status),            (pTextInfo->type),            (pDeliverTextInfo->alpha),            (pTextInfo->sca),            (pDeliverTextInfo->oa),            (pDeliverTextInfo->scts)        );                uConLen = 0;        for(uSeg = 1; uSeg <= pDeliverTextInfo->con.msgTot; uSeg++)        {            uConLen += g_asConSMSBuf[iBufIdx].asSeg[uSeg-1].uLen;        }        APP_DEBUG(",data length:%u",uConLen);        APP_DEBUG("\r\n"); //Print CR LF        for(uSeg = 1; uSeg <= pDeliverTextInfo->con.msgTot; uSeg++)        {            APP_DEBUG("data = %s ,len = %d",                g_asConSMSBuf[iBufIdx].asSeg[uSeg-1].aData,                g_asConSMSBuf[iBufIdx].asSeg[uSeg-1].uLen            );        }        APP_DEBUG("\r\n"); //Print CR LF        //Reset CON-SMS context        bResult = ConSMSBuf_ResetCtx(g_asConSMSBuf,CON_SMS_BUF_MAX_CNT,iBufIdx);        if(FALSE == bResult)        {            APP_DEBUG("Enter Hdlr_RecvNewSMS,WARNING! ConSMSBuf_ResetCtx FAIL! iBufIdx:%d\r\n",iBufIdx);        }        Ql_MEM_Free(pTextInfo);                return;    }        APP_DEBUG("<-- RIL_SMS_ReadSMS_Text OK. eCharSet:LIB_SMS_CHARSET_GSM,nIndex:%u -->\r\n",nIndex);    APP_DEBUG("status:%u,type:%u,alpha:%u,sca:%s,oa:%s,scts:%s,data length:%u\r\n",        pTextInfo->status,        pTextInfo->type,        pDeliverTextInfo->alpha,        pTextInfo->sca,        pDeliverTextInfo->oa,        pDeliverTextInfo->scts,        pDeliverTextInfo->length);    APP_DEBUG("data = %s\r\n",(pDeliverTextInfo->data));		length1 = Ql_strlen(pDeliverTextInfo->data);	SMS_Length = Ql_strlen(pDeliverTextInfo->data);	for(i=0; i < length1 ; i++)	{		msg_buffer[i] = (pDeliverTextInfo->data)[i];	}    	APP_DEBUG("%d\r\n", length1);	APP_DEBUG("data1 = %s\r\n",msg_buffer);		char FIRST_CONDITION_CLEAR_FOR_SMS=0;		p = Ql_strstr(msg_buffer,"*CON#");	APP_DEBUG("\r\n<---p=%x--->\r\n",p);	// *CON#CVID#50150847#	if(p)	{		q = Ql_strstr(msg_buffer,"CVID#");	//	APP_DEBUG("\r\n<---q=%x--->\r\n",q);		if(q)		{		    if((*(q+13) == '#') && (*(q+14) == '\0'))			{				p = strtok((q+4), "#");								// Device Id will be stored into p				strcpy(device_id_rcv, p);								for(i=0; i<10; i++)				{					if(device_id_rcv[i] =='\0') {break;}					if((device_id_rcv[i] >=48) && (device_id_rcv[i] <= 57))					{						(DEVICE_ID[i] = device_id_rcv[i]);						ID_FLAG = 1;					}					else					{						APP_DEBUG("Invalid, Only numerical value should be present in the device ID\r\n");						Ql_strcpy(aPhNum, pDeliverTextInfo->oa);						SEND_SMS(1,"Invalid device ID, Only numerical value should be present\0",aPhNum);						ID_FLAG = 0;						break;					}			    }				if(ID_FLAG == 1)				{					ID_FLAG = 0;					APP_DEBUG("<---DEVICE ID: %s --->\r\n",DEVICE_ID);					WRITE_DATA_TO_UFS(4, DEVICE_ID);						Ql_sprintf(aReplyCon,"%s sets successfully\0",DEVICE_ID);					Ql_strcpy(aPhNum, pDeliverTextInfo->oa);					SEND_SMS(1,aReplyCon,aPhNum);				}			}			else			{				APP_DEBUG("SMS Length not matched\r\n");				Ql_strcpy(aPhNum, pDeliverTextInfo->oa);				SEND_SMS(1,"SMS Length not matched\0",aPhNum);			}						FIRST_CONDITION_CLEAR_FOR_SMS = 1;			APP_DEBUG("<-- DEVICE ID => %s -->\r\n",DEVICE_ID);		}					q = Ql_strstr(msg_buffer,"BAUDRATE#");		if(q)		{			char *r=NULL;			bool baudrate_valid_flag = 0;			u32 temp_baudrate=0;						r = Ql_strstr(msg_buffer,"4800");			if(r)			{				baudrate_valid_flag = 1;				temp_baudrate = (((r[0] - 48) * 1000) +  ((r[1] - 48) * 100) + ((r[2] - 48) * 10) + (r[3] - 48));								APP_DEBUG("<-- BAUDRATE SESSION 4800 RCV BAUDRATE => %ld", temp_baudrate);			}						r = Ql_strstr(msg_buffer,"9600");			if(r)			{				baudrate_valid_flag = 1;				temp_baudrate = (((r[0] - 48) * 1000) +  ((r[1] - 48) * 100) + ((r[2] - 48) * 10) + (r[3] - 48));								APP_DEBUG("<-- BAUDRATE SESSION 9600 RCV BAUDRATE => %ld", temp_baudrate);			}						r = Ql_strstr(msg_buffer,"19200");			if(r)			{				baudrate_valid_flag = 1;				temp_baudrate = (((r[0] - 48) * 10000) +  ((r[1] - 48) * 1000) + ((r[2] - 48) * 100) + ((r[3] - 48) * 10) + (r[4] - 48));								APP_DEBUG("<-- BAUDRATE SESSION 19200 RCV BAUDRATE => %ld", temp_baudrate);			}						r = Ql_strstr(msg_buffer,"38400");			if(r)			{				baudrate_valid_flag = 1;				temp_baudrate = (((r[0] - 48) * 10000) +  ((r[1] - 48) * 1000) + ((r[2] - 48) * 100) + ((r[3] - 48) * 10) + (r[4] - 48));								APP_DEBUG("<-- BAUDRATE SESSION 38400 RCV BAUDRATE => %ld", temp_baudrate);			}						r = Ql_strstr(msg_buffer,"57600");			if(r)			{				baudrate_valid_flag = 1;				temp_baudrate = (((r[0] - 48) * 10000) +  ((r[1] - 48) * 1000) + ((r[2] - 48) * 100) + ((r[3] - 48) * 10) + (r[4] - 48));								APP_DEBUG("<-- BAUDRATE SESSION 57600 RCV BAUDRATE => %ld", temp_baudrate);			}						r = Ql_strstr(msg_buffer,"115200");			if(r)			{				baudrate_valid_flag = 1;				temp_baudrate = (((r[0] - 48) * 100000) +  ((r[1] - 48) * 10000) + ((r[2] - 48) * 1000) + ((r[3] - 48) * 100) + ((r[4] - 48) * 100) + (r[5] - 48));								APP_DEBUG("<-- BAUDRATE SESSION 115200 RCV BAUDRATE => %ld", temp_baudrate);			}						if(baudrate_valid_flag == 1)			{				if(msg_buffer[SMS_Length - 1] == '#')				{					char Stored_Array[150];										port2_dcb.baudrate = temp_baudrate;					APP_DEBUG("<-- port2_dcb.baudrate: %ld", port2_dcb.baudrate);										Ql_sprintf(Stored_Array,"BAUDRATE:%06d,PARITY:%d,PROJ-NAME:%s,\0",port2_dcb.baudrate, port2_dcb.parity, MODEL_NAME);										WRITE_DATA_TO_UFS(1, Stored_Array);										Ql_sprintf(aReplyCon,"VALID SMS, BAUDRATE SET AS: %ld\0", port2_dcb.baudrate);					Ql_strcpy(aPhNum, pDeliverTextInfo->oa);					SEND_SMS(1,aReplyCon,aPhNum);					Ql_Reset(1000);				}				else				{					APP_DEBUG("<-- END OF THE MSG NOT MATCH\r\n");					Ql_sprintf(aReplyCon,"END OF SMS IS NOT MATCH\0");				}			}			else{APP_DEBUG("<-- BAUDRATE INVALID\r\n"); Ql_sprintf(aReplyCon,"BAUDRATE INVALID\0");}						Ql_strcpy(aPhNum, pDeliverTextInfo->oa);			SEND_SMS(1,aReplyCon,aPhNum);			FIRST_CONDITION_CLEAR_FOR_SMS = 1;		}				q = Ql_strstr(msg_buffer,"PARITY#");		if(q)		{ 			char *r=NULL;			bool parity_valid_flag = 0;			char temp_parity=0;						r = Ql_strstr(msg_buffer,"NONE");			if(r)			{				parity_valid_flag = 1;				temp_parity = 0;								APP_DEBUG("<-- PRITY SESSION NONE RCV PARITY=> %d", temp_parity);			}					r = Ql_strstr(msg_buffer,"ODD");			if(r)			{				parity_valid_flag = 1;				temp_parity = 1;								APP_DEBUG("<-- PRITY SESSION ODD RCV PARITY=> %d", temp_parity);			}						r = Ql_strstr(msg_buffer,"EVEN");			if(r)			{				parity_valid_flag = 1;				temp_parity = 2;								APP_DEBUG("<-- PARITY SESSION EVEN RCV PARITY=> %d", temp_parity);			}						if(parity_valid_flag == 1)			{				if(msg_buffer[SMS_Length - 1] == '#')				{					char Stored_Array[150];										port2_dcb.parity = temp_parity;					APP_DEBUG("<-- port2_dcb.parity: %ld", port2_dcb.parity);										Ql_sprintf(Stored_Array,"BAUDRATE:%06d,PARITY:%d,PROJ-NAME:%s,\0",port2_dcb.baudrate, port2_dcb.parity, MODEL_NAME);					WRITE_DATA_TO_UFS(1, Stored_Array);										Ql_sprintf(aReplyCon,"VALID SMS, PARITY SET: %d\0",port2_dcb.parity);					Ql_strcpy(aPhNum, pDeliverTextInfo->oa);					SEND_SMS(1,aReplyCon,aPhNum);					Ql_Reset(1000);				}				else{APP_DEBUG("<-- END OF THE MSG NOT MATCH\r\n"); Ql_sprintf(aReplyCon,"END OF THE SMS NOT MATCH\0");}			}			else{APP_DEBUG("<-- PARITY INVALID\r\n");Ql_sprintf(aReplyCon,"PARITY INVALID\0");}						Ql_strcpy(aPhNum, pDeliverTextInfo->oa);			SEND_SMS(1,aReplyCon,aPhNum);			FIRST_CONDITION_CLEAR_FOR_SMS = 1;		}				q = Ql_strstr(msg_buffer,"DCH#");		if(q)		{			APP_DEBUG("<-- ENTER IN DATA SEND SESSION\r\n");					GPRS_TCP_Program(NO_COMM_WITH_CONTROLLER_PACKET);			}	}	else	{		p = Ql_strstr(msg_buffer,"*GET#GCON#");		if(p)		{				if((*(p+9) == '#') && (*(p+10) == '\0'))     // from * to # length is 9			{				Ql_strcpy(aPhNum, pDeliverTextInfo->oa);				APP_DEBUG("<-- Replying SMS... -->\r\n");			/*	Ql_sprintf(aReplyCon,"VERSION-%s, Model=%s, ID=%s, APN=%s, Config Topic name=%s, Publish Topic name=%s, Broker name = torlenzmqtt.remotemonitor.in\0",VERSION,MODEL_NAME,DEVICE_ID,APN_NAME,test_topic_SUB_array[0],test_topic_PUB_array[0]);*/			    Ql_sprintf(aReplyCon,"VERSION-%s, Model=%s, ID=%s, APN=%s",VERSION,MODEL_NAME,DEVICE_ID,APN_NAME);				APP_DEBUG("%s\r\n",aReplyCon);				SEND_SMS(1,aReplyCon,aPhNum);				FIRST_CONDITION_CLEAR_FOR_SMS = 1;			}			else			{				FIRST_CONDITION_CLEAR_FOR_SMS = 0;			}		}				p = Ql_strstr(msg_buffer,"*GET#GSTATUS#");          // Command-> Send Status Details By SMS		if(p)		{				if((*(p+12) == '#') && (*(p+13) == '\0'))      // from * to # length is 12			{				u32 signal_strength, ber; 				ret = RIL_NW_GetSignalQuality(&signal_strength, &ber);				APP_DEBUG("<-- Signal strength:%02d, BER:%d -->\r\n", signal_strength, ber);				signal_strength= (signal_strength * 100 / 32);				APP_DEBUG("<-- Signal strength:%02d, BER:%d -->\r\n", signal_strength, ber);				Ql_strcpy(aPhNum, pDeliverTextInfo->oa);				APP_DEBUG("<-- Replying SMS... -->\r\n");				Ql_sprintf(aReplyCon,"VERSION-%s,ID=%s,signal strength=%d,NETWORK STATUS INDICATOR=%d\0", VERSION, DEVICE_ID, signal_strength,NETWORK_STATUS_INDICATOR); 				APP_DEBUG("<-- %s\r\n",aReplyCon);				SEND_SMS(1,aReplyCon,aPhNum);				FIRST_CONDITION_CLEAR_FOR_SMS = 1;			}			else			{				FIRST_CONDITION_CLEAR_FOR_SMS = 0;			}		}				p = Ql_strstr(msg_buffer,"*GET#PROJECTNAME#");		if(p)		{			if((*(p+16) == '#') && (*(p+17) == '\0')) 			{				Ql_strcpy(aPhNum, pDeliverTextInfo->oa);				APP_DEBUG("<-- Replying SMS... -->\r\n");				Ql_sprintf(aReplyCon,"PROJECT NAME: %s\0",MODEL_NAME);				APP_DEBUG("%s\r\n",aReplyCon);				SEND_SMS(1,aReplyCon,aPhNum);				FIRST_CONDITION_CLEAR_FOR_SMS = 1;			}			else			{				FIRST_CONDITION_CLEAR_FOR_SMS = 0;			}		}			q = Ql_strstr(msg_buffer,"*GET#GSERMOD#");		if(q)		{			if((*(q+12) == '#') && (*(q+13) == '\0')) 			{								Ql_strcpy(aPhNum, pDeliverTextInfo->oa); 				APP_DEBUG("<-- Replying SMS... -->\r\n");				Ql_sprintf(aReplyCon,"VERSION:%s, ID=%s, SLAVE ID1=%03d, SLAVE ID2=%03d, SLAVE ID3=%03d, SLAVE ID4=%03d, BAUDRATE = %ld, PARITYBITS = %d\0",VERSION, DEVICE_ID, MOD_SLAVE[0], MOD_SLAVE[1], MOD_SLAVE[2], MOD_SLAVE[3], port2_dcb.baudrate, port2_dcb.parity);				APP_DEBUG("%s\r\n",aReplyCon); 				SEND_SMS(1,aReplyCon,aPhNum);				FIRST_CONDITION_CLEAR_FOR_SMS = 1;			}			else			{				FIRST_CONDITION_CLEAR_FOR_SMS = 0;			}		}	}		if(FIRST_CONDITION_CLEAR_FOR_SMS == 0)	{		Ql_strcpy(aPhNum, pDeliverTextInfo->oa);		SEND_SMS(1,"PLEASE CHECK FORMAT, MESSAGE INVALID\0",aPhNum);	}		    Ql_strcpy(aPhNum, pDeliverTextInfo->oa);    Ql_MEM_Free(pTextInfo);    return;}static bool SMS_Initialize(void){    s32 iResult = 0;    u8  nCurrStorage = 0;    u32 nUsed = 0;    u32 nTotal = 0;        // Set SMS storage:    // By default, short message is stored into SIM card. You can change the storage to ME if needed, or    // you can do it again to make sure the short message storage is SIM card.    #if 0    {        iResult = RIL_SMS_SetStorage(RIL_SMS_STORAGE_TYPE_SM,&nUsed,&nTotal);        if (RIL_ATRSP_SUCCESS != iResult)        {            APP_DEBUG("Fail to set SMS storage, cause:%d\r\n", iResult);            return FALSE;        }        APP_DEBUG("<-- Set SMS storage to SM, nUsed:%u,nTotal:%u -->\r\n", nUsed, nTotal);        iResult = RIL_SMS_GetStorage(&nCurrStorage, &nUsed ,&nTotal);        if(RIL_ATRSP_SUCCESS != iResult)        {            APP_DEBUG("Fail to get SMS storage, cause:%d\r\n", iResult);            return FALSE;        }        APP_DEBUG("<-- Check SMS storage: curMem=%d, used=%d, total=%d -->\r\n", nCurrStorage, nUsed, nTotal);    }    #endif    // Enable new short message indication    // By default, the auto-indication for new short message is enalbed. You can do it again to     // make sure that the option is open.    #if 0    {        iResult = Ql_RIL_SendATCmd("AT+CNMI=2,1",Ql_strlen("AT+CNMI=2,1"),NULL,NULL,0);        if (RIL_AT_SUCCESS != iResult)        {            APP_DEBUG("Fail to send \"AT+CNMI=2,1\", cause:%d\r\n", iResult);            return FALSE;        }        APP_DEBUG("<-- Enable new SMS indication -->\r\n");    }    #endif    // Delete all existed short messages (if needed)    iResult = RIL_SMS_DeleteSMS(0, RIL_SMS_DEL_ALL_MSG);    if (iResult != RIL_AT_SUCCESS)    {        APP_DEBUG("Fail to delete all messages, cause:%d\r\n", iResult);        return FALSE;    } //   APP_DEBUG("<-- Delete all existed messages -->\r\n");        return TRUE;}static s8 ConSMSBuf_GetIndex(ConSMSStruct *pCSBuf,u8 uCSMaxCnt,ST_RIL_SMS_Con *pCon){	u8 uIdx = 0;	    if(    (NULL == pCSBuf) || (0 == uCSMaxCnt)         || (NULL == pCon)      )    {        APP_DEBUG("Enter ConSMSBuf_GetIndex,FAIL! Parameter is INVALID. pCSBuf:%x,uCSMaxCnt:%d,pCon:%x\r\n",pCSBuf,uCSMaxCnt,pCon);        return -1;    }    if((pCon->msgTot) > CON_SMS_MAX_SEG)    {        APP_DEBUG("Enter ConSMSBuf_GetIndex,FAIL! msgTot:%d is larger than limit:%d\r\n",pCon->msgTot,CON_SMS_MAX_SEG);        return -1;    }    	for(uIdx = 0; uIdx < uCSMaxCnt; uIdx++)  //Match all exist records	{        if(    (pCon->msgRef == pCSBuf[uIdx].uMsgRef)            && (pCon->msgTot == pCSBuf[uIdx].uMsgTot)          )        {            return uIdx;        }	}	for (uIdx = 0; uIdx < uCSMaxCnt; uIdx++)	{		if (0 == pCSBuf[uIdx].uMsgTot)  //Find the first unused record		{            pCSBuf[uIdx].uMsgTot = pCon->msgTot;            pCSBuf[uIdx].uMsgRef = pCon->msgRef;            			return uIdx;		}	}    APP_DEBUG("Enter ConSMSBuf_GetIndex,FAIL! No avail index in ConSMSBuf,uCSMaxCnt:%d\r\n",uCSMaxCnt);    	return -1;}/***************************************************************************** * FUNCTION *  ConSMSBuf_AddSeg * * DESCRIPTION *  This function is used to add segment in <pCSBuf> *   * PARAMETERS *  <pCSBuf>     The SMS index in storage,it starts from 1 *  <uCSMaxCnt>  TRUE: The module should reply a SMS to the sender; FALSE: The module only read this SMS. *  <uIdx>       Index of <pCSBuf> which will be stored *  <pCon>       The pointer of 'ST_RIL_SMS_Con' data *  <pData>      The pointer of CON-SMS-SEG data *  <uLen>       The length of CON-SMS-SEG data * * RETURNS *  FALSE:   FAIL! *  TRUE: SUCCESS. * * NOTE *  1. This is an internal function *****************************************************************************/static bool ConSMSBuf_AddSeg(ConSMSStruct *pCSBuf,u8 uCSMaxCnt,u8 uIdx,ST_RIL_SMS_Con *pCon,u8 *pData,u16 uLen){    u8 uSeg = 1;        if(    (NULL == pCSBuf) || (0 == uCSMaxCnt)         || (uIdx >= uCSMaxCnt)        || (NULL == pCon)        || (NULL == pData)        || (uLen > (CON_SMS_SEG_MAX_CHAR * 4))      )    {        APP_DEBUG("Enter ConSMSBuf_AddSeg,FAIL! Parameter is INVALID. pCSBuf:%x,uCSMaxCnt:%d,uIdx:%d,pCon:%x,pData:%x,uLen:%d\r\n",pCSBuf,uCSMaxCnt,uIdx,pCon,pData,uLen);        return FALSE;    }    if((pCon->msgTot) > CON_SMS_MAX_SEG)    {        APP_DEBUG("Enter ConSMSBuf_GetIndex,FAIL! msgTot:%d is larger than limit:%d\r\n",pCon->msgTot,CON_SMS_MAX_SEG);        return FALSE;    }    uSeg = pCon->msgSeg;    pCSBuf[uIdx].abSegValid[uSeg-1] = TRUE;    Ql_memcpy(pCSBuf[uIdx].asSeg[uSeg-1].aData,pData,uLen);    pCSBuf[uIdx].asSeg[uSeg-1].uLen = uLen;    	return TRUE;}/***************************************************************************** * FUNCTION *  ConSMSBuf_IsIntact * * DESCRIPTION *  This function is used to check the CON-SMS is intact or not *   * PARAMETERS *  <pCSBuf>     The SMS index in storage,it starts from 1 *  <uCSMaxCnt>  TRUE: The module should reply a SMS to the sender; FALSE: The module only read this SMS. *  <uIdx>       Index of <pCSBuf> which will be stored *  <pCon>       The pointer of 'ST_RIL_SMS_Con' data * * RETURNS *  FALSE:   FAIL! *  TRUE: SUCCESS. * * NOTE *  1. This is an internal function *****************************************************************************/static bool ConSMSBuf_IsIntact(ConSMSStruct *pCSBuf,u8 uCSMaxCnt,u8 uIdx,ST_RIL_SMS_Con *pCon){    u8 uSeg = 1;	    if(    (NULL == pCSBuf)         || (0 == uCSMaxCnt)         || (uIdx >= uCSMaxCnt)        || (NULL == pCon)      )    {        APP_DEBUG("Enter ConSMSBuf_IsIntact,FAIL! Parameter is INVALID. pCSBuf:%x,uCSMaxCnt:%d,uIdx:%d,pCon:%x\r\n",pCSBuf,uCSMaxCnt,uIdx,pCon);        return FALSE;    }    if((pCon->msgTot) > CON_SMS_MAX_SEG)    {        APP_DEBUG("Enter ConSMSBuf_GetIndex,FAIL! msgTot:%d is larger than limit:%d\r\n",pCon->msgTot,CON_SMS_MAX_SEG);        return FALSE;    }        	for (uSeg = 1; uSeg <= (pCon->msgTot); uSeg++)	{        if(FALSE == pCSBuf[uIdx].abSegValid[uSeg-1])        {            APP_DEBUG("Enter ConSMSBuf_IsIntact,FAIL! uSeg:%d has not received!\r\n",uSeg);            return FALSE;        }	}        return TRUE;}/***************************************************************************** * FUNCTION *  ConSMSBuf_ResetCtx * * DESCRIPTION *  This function is used to reset ConSMSBuf context *   * PARAMETERS *  <pCSBuf>     The SMS index in storage,it starts from 1 *  <uCSMaxCnt>  TRUE: The module should reply a SMS to the sender; FALSE: The module only read this SMS. *  <uIdx>       Index of <pCSBuf> which will be stored * * RETURNS *  FALSE:   FAIL! *  TRUE: SUCCESS. * * NOTE *  1. This is an internal function *****************************************************************************/static bool ConSMSBuf_ResetCtx(ConSMSStruct *pCSBuf,u8 uCSMaxCnt,u8 uIdx){    if(    (NULL == pCSBuf) || (0 == uCSMaxCnt)         || (uIdx >= uCSMaxCnt)      )    {        APP_DEBUG("Enter ConSMSBuf_ResetCtx,FAIL! Parameter is INVALID. pCSBuf:%x,uCSMaxCnt:%d,uIdx:%d\r\n",pCSBuf,uCSMaxCnt,uIdx);        return FALSE;    }        //Default reset    Ql_memset(&pCSBuf[uIdx],0x00,sizeof(ConSMSStruct));    //TODO: Add special reset here        return TRUE;}static void GPRS_TCP_Program(char PACKET_TYPE){    s32 ret;    //s32 pdpCntxtId;    ST_PDPContxt_Callback callback_gprs_func = {        Callback_GPRS_Actived,        Callback_GPRS_Deactived    };	if(socket_flag == 1)	{				//1. Register GPRS callback		pdpCntxtId = Ql_GPRS_GetPDPContextId();		if (GPRS_PDP_ERROR == pdpCntxtId)		{			APP_DEBUG("No PDP context is available\r\n");			ret=Ql_GPRS_Deactivate(pdpCntxtId);			APP_DEBUG("<-- Deactivated GPRS1, cause=%d -->\r\n\r\n", ret);			ret = RIL_NW_ClosePDPContext();			APP_DEBUG("<-- Close PDP context, ret=%d -->\r\n", ret);			return ret;		}		else		{			//Ql_Reset(0);		}		ret = Ql_GPRS_Register(pdpCntxtId, &callback_gprs_func, NULL);		if (GPRS_PDP_SUCCESS == ret)		{			APP_DEBUG("<-- Register GPRS callback function -->\r\n");		}else{			APP_DEBUG("<-- Fail to register GPRS, cause=%d. -->\r\n", ret);			return;		}		//2. Configure PDP		ret = Ql_GPRS_Config(pdpCntxtId, &m_GprsConfig);		if (GPRS_PDP_SUCCESS == ret)		{			APP_DEBUG("<-- Configure PDP context -->\r\n");		}else{			APP_DEBUG("<-- Fail to configure GPRS PDP, cause=%d. -->\r\n", ret);			return;		}		//3. Activate GPRS PDP context		APP_DEBUG("<-- Activating GPRS... -->\r\n");		ret = Ql_GPRS_Activate(pdpCntxtId);		if (ret == GPRS_PDP_SUCCESS)		{			m_GprsActState = 1;			APP_DEBUG("<-- Activate GPRS successfully. -->\r\n\r\n");		}        if(ret == GPRS_PDP_WOULDBLOCK)        {            			APP_DEBUG("<-- Waiting for GPRS ACTIVED. -->\r\n\r\n");            return;         }else{			APP_DEBUG("<-- Fail to activate GPRS, cause=%d. -->\r\n\r\n", ret);			return;		}			}    //7. Send data to socket	if(m_SocketConnState > 0)// checking for socket connection    {        //7.1 Send data		s32 ret,i;		u16 Data_Packet_Length;		u8 START_OF_THE_STRING = '*',END_OF_THE_REQUEST_STRING = ':';		u8 START_OF_THE_MESSAGE[60], Data_Packet_Send_To_Server[4*1024];		u8 DATA_STRING[6] = "DATA\0", COMMUNICATION_ERROR[6] = "CEWC\0", COMMUNICATION_ERR_PORT2[6] = "CEC1\0", COMMUNICATION_ERR_PORT3[6] = "CEC2\0"; 		u8 SLAVE_ID_START = 1, SLAVE_ID_END = 3;				Ql_memset(Data_Packet_Send_To_Server,0,sizeof(Data_Packet_Send_To_Server));		Ql_memset(START_OF_THE_MESSAGE,0,sizeof(START_OF_THE_MESSAGE));				Ql_sprintf(START_OF_THE_MESSAGE,"%c,%s,%s,%s,%s",START_OF_THE_STRING, DEVICE_ID, MODEL_NAME, UTC_DATE_TIME, VERSION);				if(DATA_PACKET == PACKET_TYPE)		{			Ql_sprintf(Data_Packet_Send_To_Server, "%s,%03d,%s,%02d,%02d,%c,%s#\0",START_OF_THE_MESSAGE, ERROR_STATUS_1, DATA_STRING, SLAVE_ID_START, SLAVE_ID_END, END_OF_THE_REQUEST_STRING, DATA_FROM_CONTROLLER);						Data_Packet_Length = strlen(Data_Packet_Send_To_Server);			NO_COMM_WITH_CONTROLLER_COUNT = 0;			COMMUNICATION_WITH_CONTROLLER_FLAG = 1;		}		else if(PACKET_TYPE == NO_COMM_WITH_CONTROLLER_PACKET)		{			comm_flag = 0;			APP_DEBUG("\r\n<-- No Communication Data\r\n");			Ql_sprintf(Data_Packet_Send_To_Server, "%s,%03d,%s,%02d,%02d,%c,%s#\0",START_OF_THE_MESSAGE, ERROR_STATUS_1, COMMUNICATION_ERROR, SLAVE_ID_START, SLAVE_ID_END, END_OF_THE_REQUEST_STRING, DATA_FROM_CONTROLLER);						Data_Packet_Length = strlen(Data_Packet_Send_To_Server); 			NO_COMM_WITH_CONTROLLER_COUNT = 0;			COMMUNICATION_WITH_CONTROLLER_FLAG = 1;		}		//	APP_DEBUG("<-- Data_Packet_Length = %d\r\n",Data_Packet_Length);				APP_DEBUG("<-- Sending data(len=%d): %s-->\r\n", Data_Packet_Length, Data_Packet_Send_To_Server);		        ret = Ql_SOC_Send(m_SocketId, (u8*)Data_Packet_Send_To_Server, Data_Packet_Length);        if (ret == Data_Packet_Length)         {            APP_DEBUG("<-- Send socket data successfully. --> \r\n");			//SYSTEM_WATCHDOG_FLAG = 1;			DATA_SEND_TO_SERVER_FLAG = 1;						        }else{            APP_DEBUG("<-- Fail to send socket data. --> \r\n");            Ql_SOC_Close(m_SocketId);			ret = Ql_GPRS_DeactivateEx(pdpCntxtId, TRUE);			APP_DEBUG("<-- Deactivated GPRS, cause=%d -->\r\n\r\n", ret);			ret=Ql_GPRS_Deactivate(pdpCntxtId);			APP_DEBUG("<-- Deactivated GPRS1, cause=%d -->\r\n\r\n", ret);			ret = RIL_NW_ClosePDPContext();			APP_DEBUG("<-- Close PDP context, ret=%d -->\r\n", ret);			socket_flag = 1;			m_SocketConnState=0;        }		APP_DEBUG("< Finish >\r\n");	} 	else	{		 APP_DEBUG("<-- m_SocketConnState is zero\r\n");	}	}void Callback_Socket_Connect(s32 socketId, s32 errCode, void* customParam ){    if (errCode == SOC_SUCCESS)    {              APP_DEBUG("<--Callback: socket connect successfully.-->\r\n");        SOCKET_IN_WOULD_BLOCK_FLAG = 0;        m_SocketConnState = 1;    }else    {        APP_DEBUG("<--Callback: socket connect failure,(socketId=%d),errCode=%d-->\r\n",socketId,errCode);		if(SERVER2_SETTING_SELECTION_FLAG == 0)                              //server selection considering fail condition of server		{			SERVER2_SETTING_SELECTION_FLAG = 1;		}		else if(SERVER2_SETTING_SELECTION_FLAG == 1){			SERVER2_SETTING_SELECTION_FLAG = 0;		}		APP_DEBUG("<-- SERVER2_SETTING_SELECTION_FLAG = %d-->\r\n", SERVER2_SETTING_SELECTION_FLAG);        m_SocketConnState = 0;		SOCKET_IN_WOULD_BLOCK_FLAG = 0;		        Ql_SOC_Close(socketId);    }}void Callback_GPRS_Actived(u8 contexId, s32 errCode, void* customParam){    s32 ret;	u8 m_ipAddress[4], m_ipAddress_1[4] ; 	Ql_memset(m_ipAddress,0,5);	Ql_memset(m_ipAddress_1,0,5);            ST_SOC_Callback callback_soc_func = {        Callback_Socket_Connect,        Callback_Socket_Close,        NULL,        Callback_Socket_Read,            Callback_Socket_Write    };        	    if(errCode == SOC_SUCCESS)    {                m_GprsActState = 1;       socket_flag = 0;		SOCKET_IN_WOULD_BLOCK_FLAG = 0;        APP_DEBUG("<--CallBack: active GPRS successfully.-->\r\n");        		//4. Register Socket callback		ret = Ql_SOC_Register(callback_soc_func, NULL);		if (SOC_SUCCESS == ret)		{			APP_DEBUG("<-- Register socket callback function -->\r\n");		}else{			APP_DEBUG("<-- Fail to register socket callback, cause=%d. -->\r\n", ret);			return;		}		//socket_flag = 0;		APP_DEBUG("<-- enter socket\r\n");		//5. Create socket		m_SocketId = Ql_SOC_Create(pdpCntxtId, SOC_TYPE_TCP);		if (m_SocketId >= 0)		{			APP_DEBUG("<-- Create socket successfully, socket id=%d. -->\r\n", m_SocketId);		}else{			APP_DEBUG("<-- Fail to create socket, cause=%d. -->\r\n", m_SocketId);			return;		}							//6. Connect to server		if( SERVER2_SETTING_SELECTION_FLAG == 0)		{			ret = Ql_IpHelper_ConvertIpAddr(m_SrvADDR, (u32 *)m_ipAddress);			if (SOC_SUCCESS == ret) // ip address is xxx.xxx.xxx.xxx			{				APP_DEBUG("<-- Convert Ip Address successfully,m_ipaddress=%d,%d,%d,%d -->\r\n",m_ipAddress[0],m_ipAddress[1],m_ipAddress[2],m_ipAddress[3]);			}else{				APP_DEBUG("<-- Fail to convert IP Address --> \r\n");				return;			}			//6.2 Connect to server			APP_DEBUG("<-- Connecting to server(IP:%d.%d.%d.%d, port:%d)... -->\r\n", m_ipAddress[0],m_ipAddress[1],m_ipAddress[2],m_ipAddress[3], m_SrvPort);			ret = Ql_SOC_Connect(m_SocketId,(u32) m_ipAddress, m_SrvPort);			if (SOC_SUCCESS == ret)			{				m_SocketConnState = 1;				APP_DEBUG("<-- Connect to server successfully -->\r\n");				SOCKET_IN_WOULD_BLOCK_FLAG = 0;			}			else			{				if(SOC_WOULDBLOCK == ret)				{					SOCKET_IN_WOULD_BLOCK_FLAG = 1;					APP_DEBUG("<-- Waiting to SOC Connect : WOULD_BLOCK -->\r\n");                   				   return;				}				APP_DEBUG("<-- Fail to connect server 1, cause=%d -->\r\n", ret);				APP_DEBUG("<-- Close socket.-->\r\n");				Ql_SOC_Close(m_SocketId);				m_SocketId = -1;				SERVER2_SETTING_SELECTION_FLAG = 1;				return;			}		}		else		{			ret = Ql_IpHelper_ConvertIpAddr(m_SrvADDR_1, (u32 *)m_ipAddress_1);			if (SOC_SUCCESS == ret) // ip address is xxx.xxx.xxx.xxx			{				APP_DEBUG("<-- Convert Ip Address successfully,m_ipaddress=%d,%d,%d,%d -->\r\n",m_ipAddress_1[0],m_ipAddress_1[1],m_ipAddress_1[2],m_ipAddress_1[3]);			}else{				APP_DEBUG("<-- Fail to convert IP Address --> \r\n");				return;			}			//6.2 Connect to server			APP_DEBUG("<-- Connecting to server(IP:%d.%d.%d.%d, port:%d)... -->\r\n", m_ipAddress_1[0],m_ipAddress_1[1],m_ipAddress_1[2],m_ipAddress_1[3], m_SrvPort_1);			ret = Ql_SOC_Connect(m_SocketId,(u32) m_ipAddress_1, m_SrvPort_1);			if (SOC_SUCCESS == ret)			{				m_SocketConnState = 1;				SOCKET_IN_WOULD_BLOCK_FLAG = 0;				APP_DEBUG("<-- Connect to server successfully -->\r\n");			}			else			{				if(SOC_WOULDBLOCK == ret)				{					SOCKET_IN_WOULD_BLOCK_FLAG = 1;					APP_DEBUG("<-- Waiting to SOC Connect : WOULD_BLOCK -->\r\n");                   				   return;				}								APP_DEBUG("<-- Fail to connect to server 2, cause=%d -->\r\n", ret);				APP_DEBUG("<-- Close socket.-->\r\n");				Ql_SOC_Close(m_SocketId);				m_SocketId = -1;				SERVER2_SETTING_SELECTION_FLAG = 0;				return;			}				}		    }	else    {        APP_DEBUG("<--CallBack: active GPRS successfully,errCode=%d-->\r\n",errCode);    }      }static void Callback_GPRS_Deactived(u8 contextId, s32 errCode, void* customParam ){    if (errCode == SOC_SUCCESS)    {        APP_DEBUG("<--CallBack: deactivated GPRS successfully.-->\r\n");     }else{        APP_DEBUG("<--CallBack: fail to deactivate GPRS, cause=%d)-->\r\n", errCode);     }    if (1 == m_GprsActState)    {        m_GprsActState = 0;        APP_DEBUG("<-- GPRS drops down -->\r\n"); 		GPRS_flag = 0;    }}////// This callback function is invoked when the socket connection is disconnected by server or network.//static void Callback_Socket_Close(s32 socketId, s32 errCode, void* customParam ){    if (errCode == SOC_SUCCESS)    {        APP_DEBUG("<--CallBack: close socket successfully.-->\r\n");     }    else if(errCode == SOC_BEARER_FAIL)    {           APP_DEBUG("<--CallBack: fail to close socket,(socketId=%d,error_cause=%d)-->\r\n", socketId, errCode);     }else{        APP_DEBUG("<--CallBack: close socket failure,(socketId=%d,error_cause=%d)-->\r\n", socketId, errCode);     }    if (0 < m_SocketConnState)    {        APP_DEBUG("<-- Socket connection is disconnected -->\r\n");         APP_DEBUG("<-- Close socket at module side -->\r\n");         Ql_SOC_Close(socketId);        m_SocketConnState = 0;    }}//// This callback function is invoked in the following case:// The return value is less than the data length to send when calling Ql_SOC_Send(), which indicates// the socket buffer is full. Application should stop sending socket data till this callback function// is invoked, which indicates application can continue to send data to socket.static void Callback_Socket_Write(s32 socketId, s32 errCode, void* customParam){    if (errCode < 0)    {        APP_DEBUG("<-- Socket error(error code:%d), close socket.-->\r\n", errCode);        Ql_SOC_Close(socketId);		m_SocketId = -1;            }else{        APP_DEBUG("<-- You can continue to send data to socket -->\r\n");    }}//This function is used for making socket connection with servervoid SOC_CONNECT_TO_SERVER(){	s32 ret;	u8 m_ipAddress[4], m_ipAddress_1[4] ; 	Ql_memset(m_ipAddress,0,5);	Ql_memset(m_ipAddress_1,0,5);	SOCKET_IN_WOULD_BLOCK_FLAG = 0;		ST_SOC_Callback callback_soc_func = {        Callback_Socket_Connect,        Callback_Socket_Close,        NULL,        Callback_Socket_Read,            Callback_Socket_Write    };		ret = Ql_SOC_Register(callback_soc_func, NULL);	if (SOC_SUCCESS == ret)	{		APP_DEBUG("<-- Register socket callback function -->\r\n");	}else{		APP_DEBUG("<-- Fail to register socket callback, cause=%d. -->\r\n", ret);		return;	}	//socket_flag = 0;	APP_DEBUG("<-- enter socket\r\n");	//5. Create socket	m_SocketId = Ql_SOC_Create(pdpCntxtId, SOC_TYPE_TCP);	if (m_SocketId >= 0)	{		APP_DEBUG("<-- Create socket successfully, socket id=%d. -->\r\n", m_SocketId);	}else{		APP_DEBUG("<-- Fail to create socket, cause=%d. -->\r\n", m_SocketId);		return;	}			if( SERVER2_SETTING_SELECTION_FLAG == 0)// If server flag is zero going to connect server 1, else going to connect server 2	{		ret = Ql_IpHelper_ConvertIpAddr(m_SrvADDR, (u32 *)m_ipAddress);		if (SOC_SUCCESS == ret) // ip address is xxx.xxx.xxx.xxx		{			APP_DEBUG("<-- Convert Ip Address successfully,m_ipaddress=%d,%d,%d,%d -->\r\n",m_ipAddress[0],m_ipAddress[1],m_ipAddress[2],m_ipAddress[3]);		}else{			APP_DEBUG("<-- Fail to convert IP Address --> \r\n");			return;		}		//6.2 Connect to server		APP_DEBUG("<-- Connecting to server(IP:%d.%d.%d.%d, port:%d)... -->\r\n", m_ipAddress[0],m_ipAddress[1],m_ipAddress[2],m_ipAddress[3], m_SrvPort);		ret = Ql_SOC_Connect(m_SocketId,(u32) m_ipAddress, m_SrvPort);		if (SOC_SUCCESS == ret)		{			m_SocketConnState = 1;			APP_DEBUG("<-- Connect to server successfully -->\r\n");			SOCKET_IN_WOULD_BLOCK_FLAG = 0;		}		else		{			if(SOC_WOULDBLOCK == ret)			{				SOCKET_IN_WOULD_BLOCK_FLAG = 1;				APP_DEBUG("<-- Waiting to SOC Connect : WOULD_BLOCK -->\r\n");                   			   return;			}			APP_DEBUG("<-- Fail to connect server 1, cause=%d -->\r\n", ret);			APP_DEBUG("<-- Close socket.-->\r\n");			Ql_SOC_Close(m_SocketId);			m_SocketId = -1;			SERVER2_SETTING_SELECTION_FLAG = 1;			return;		}	}	else	{		ret = Ql_IpHelper_ConvertIpAddr(m_SrvADDR_1, (u32 *)m_ipAddress_1);		if (SOC_SUCCESS == ret) // ip address is xxx.xxx.xxx.xxx		{			APP_DEBUG("<-- Convert Ip Address successfully,m_ipaddress=%d,%d,%d,%d -->\r\n",m_ipAddress_1[0],m_ipAddress_1[1],m_ipAddress_1[2],m_ipAddress_1[3]);		}else{			APP_DEBUG("<-- Fail to convert IP Address --> \r\n");			return;		}		//6.2 Connect to server		APP_DEBUG("<-- Connecting to server(IP:%d.%d.%d.%d, port:%d)... -->\r\n", m_ipAddress_1[0],m_ipAddress_1[1],m_ipAddress_1[2],m_ipAddress_1[3], m_SrvPort_1);		ret = Ql_SOC_Connect(m_SocketId,(u32) m_ipAddress_1, m_SrvPort_1);		if (SOC_SUCCESS == ret)		{			m_SocketConnState = 1;			SOCKET_IN_WOULD_BLOCK_FLAG = 0;			APP_DEBUG("<-- Connect to server successfully -->\r\n");		}		else		{			if(SOC_WOULDBLOCK == ret)			{				SOCKET_IN_WOULD_BLOCK_FLAG = 1;				APP_DEBUG("<-- Waiting to SOC Connect : WOULD_BLOCK -->\r\n");                   			   return;			}						APP_DEBUG("<-- Fail to connect to server 2, cause=%d -->\r\n", ret);			APP_DEBUG("<-- Close socket.-->\r\n");			Ql_SOC_Close(m_SocketId);			m_SocketId = -1;			SERVER2_SETTING_SELECTION_FLAG = 0;			return;		}		}}////// This callback function is invoked when socket data arrives.// The program should call Ql_SOC_Recv to read all data out of the socket buffer.//static void Callback_Socket_Read(s32 socketId, s32 errCode, void* customParam ){    s32 ret;    s32 offset = 0;	char *q=NULL;	    if (errCode)    {        APP_DEBUG("<-- Close socket -->\r\n");        Ql_SOC_Close(socketId);        m_SocketId = -1;        return;    }    Ql_memset(m_SocketRcvBuf, 0, SOC_RECV_BUFFER_LEN);    do    {        ret = Ql_SOC_Recv(socketId, m_SocketRcvBuf + offset, SOC_RECV_BUFFER_LEN - offset);        if((ret < SOC_SUCCESS) && (ret != SOC_WOULDBLOCK))        {            APP_DEBUG("<-- Fail to receive data, cause=%d.-->\r\n",ret);            APP_DEBUG("<-- Close socket.-->\r\n");            Ql_SOC_Close(socketId);            m_SocketId = -1;            break;        }        else if(SOC_WOULDBLOCK == ret)  // Read finish        {            APP_DEBUG("<-- Receive data from server,len(%d):%s\r\n", offset, m_SocketRcvBuf);			SYSTEM_WATCHDOG_FLAG = 1; 			if((m_SocketRcvBuf[0] == '*') && (m_SocketRcvBuf[offset-1] == '#'))			{				q = Ql_strstr(m_SocketRcvBuf, DEVICE_ID);				if(q)				{					u8 modbus_data[1024]={0},length1=0,j;					int i, length2=0 , length3=0;					bool diff_var=0;					MODBUS_WRITE_QURIES_COUNT = 0;										for(i =0 ; i < offset;i++)					{						modbus_data[i] = m_SocketRcvBuf[i];					}										if(modbus_data[22] == '#')					{						length1 = 23;						MODBUS_WRITE_QURIES_COUNT = ((modbus_data[20] - 48)*10) +(modbus_data[21]-48);						APP_DEBUG("\r\n two var valid string\r\n");						}					else if(modbus_data[21] == '#')					{						length1 = 22;						MODBUS_WRITE_QURIES_COUNT = (modbus_data[20]-48);						APP_DEBUG("\r\n one var valid string\r\n");						}					else					{						APP_DEBUG("\n\r\invalid string\r\n");								break;											}										APP_DEBUG("\n\r %d \r\n", MODBUS_WRITE_QURIES_COUNT);												for(i= 0; i < MODBUS_WRITE_QURIES_COUNT; i++)					{						for(j =0;j<11;j++)						{							if(j == 5)							{								diff_var =1;								continue;							}														if(diff_var == 1)							{								length2 =(i*10)+j-1; length3 = length1+(i*12)+j;							}							else							{								length2 =(i*10)+j; length3 = length1+(i*12)+j;							}														database[length2] = modbus_data[length3];									APP_DEBUG("\r\n lenght2 = %d , length3=%d\r\n", length2 ,length3);								APP_DEBUG("\r\nval = %c\r\n", database[length2]);													}						diff_var =0;					}					APP_DEBUG("\r\ndata = %s \r\n", database);							SEPARATE_MODBUS_DATA(MODBUS_WRITE_QURIES_COUNT,database);					MODBUS_WRITE_FLAG = 1;					APP_DEBUG("\r\enter mod write\r\n");					Ql_memset(database, 0, sizeof(database));					//GPRS_TCP_Program(VALID_DATA_RCV_FROM_SERVER_PACKET);					ret = Ql_Timer_Start(Stack_timer4,ST_Interval_4 ,TRUE);					if(ret < 0)					{						APP_DEBUG("\r\n<--failed!! stack timer Ql_Timer_Start ret=%d-->\r\n",ret);        					}					APP_DEBUG("\r\n<--stack timer Ql_Timer_Start(ID=%d,Interval=%d,) ret=%d-->\r\n",Stack_timer,ST_Interval,ret);				}			}			else			{				APP_DEBUG("\r\n<--Start Or End of The String Not Match\r\n");			}            break;        }        else // Continue to read...        {            if (SOC_RECV_BUFFER_LEN == offset)  // buffer if full            {                APP_DEBUG("<-- Receive data from server,len(%d):%s\r\n", offset, m_SocketRcvBuf);                Ql_memset(m_SocketRcvBuf, 0, SOC_RECV_BUFFER_LEN);                offset = 0;            }else{                offset += ret;            }            continue;        }    } while (TRUE);}static void mqtt_recv(u8* buffer,u32 length){	APP_DEBUG("data:%s,len:%d\r\n",buffer,length);      		char *p= NULL;		/*p = Ql_strstr(buffer, MODEL_NAME);	if(p)	{ */		char *r = NULL;		//*ST1-1 | Secure Test 1-1 - Secure#TIME:202205114114133#50150847-1#MODADD#05#001,3,		r = Ql_strstr(buffer, "TIME:"); 		if(r)		{				char *q = NULL, length;			r = r + 5;									q = Ql_strstr(buffer, DEVICE_ID);			if(q)			{				length = q - r;			    //*ST1-1 | Secure Test 1-1 - Secure#TIME:20220511411413#50150847#MODADD#05#001,3,			                                        //   20220701142144#			    APP_DEBUG("<-- length is %d --> \r\n" , length);				 				                  if(length == 15) 				{					bool ret_val = 0;										ret_val = COMPARE_TIMESTAMP_FOR_SUB_MSG(r, TIMESTAMP_SUB_MSG);  //(20220511411413# = "00000000000000\0") 										if(ret_val == 1)					{						APP_DEBUG("<-- LENGTH OF DEVICE ID IS MATCH, ENTER INTO SETTING MODE\r\n");						DEVICE_PARAMETER_CONFIGURATION(q);					}					else{APP_DEBUG("<-- TIMESTAMP OF OLD COMMAND, EXIT FROM DEVICE SETTING MODE\r\n");}				}				else{APP_DEBUG("<-- TIMESTAMP LENGTH(%d) IS NOT MATCH, EXIT FROM DEVICE SETTING MODE\r\n",length);}			}			else			{				q = Ql_strstr(p, "ALL");				if(q)				{					APP_DEBUG("<-- SETTING FOR ALL DEVICES, ENTER INTO SETTING MODE\r\n");					DEVICE_PARAMETER_CONFIGURATION(q);				}				else{APP_DEBUG("<-- DEVICE ID IS NOT MATCH EXIT FROM DEVICE SETTING MODE\r\n");}				}		}			//	else{APP_DEBUG("<-- TIME KEYWORD NOT MATCH\r\n");}	//}	// else	// {		// APP_DEBUG("<-- PROJECT IS NOT MATCH EXIT FROM DEVICE SETTING MODE\r\n");	// }		SYSTEM_WATCHDOG_FLAG = 1; }      bool COMPARE_TIMESTAMP_FOR_SUB_MSG(char *Rcv_Time_Stamp,char *Store_Time_Stamp){	char i, TIME_SET_FLAG=0;	for(i=0; i<14; i++)	{		if(Rcv_Time_Stamp[i] > Store_Time_Stamp[i])		{			TIME_SET_FLAG = 1;			break;		}		else if(Rcv_Time_Stamp[i] == Store_Time_Stamp[i])		{			continue;		}		else		{			break;		}	} 		if(TIME_SET_FLAG == 1)	{			char temp_buff[30];		for(i=0; i<14; i++)		{			TIMESTAMP_SUB_MSG[i] = Rcv_Time_Stamp[i];		}				TIMESTAMP_SUB_MSG[i] = 0;		Ql_memset(temp_buff, 0, sizeof(temp_buff));		Ql_sprintf(temp_buff,"TIME_SUB_MSG=%s#\0",TIMESTAMP_SUB_MSG);				APP_DEBUG("<-- TIME_STAMP Replace -->\r\n");	//	APP_DEBUG("\r\n=> %s\r\n", temp_buff);		WRITE_DATA_TO_UFS(13,temp_buff);		return 1;	}	else	{		APP_DEBUG("<-- TIME_STAMP NOT REPLACE -->\r\n");		APP_DEBUG("<-- TIME_STAMP: %s -->\r\n", Store_Time_Stamp);		return 0;	}}/* *ST1-1 | Secure Test 1-1 - Secure#TIME:20220701142144#50150847#1#MODADD#03#001,3,00100,020#001,3,00134,016#001,3,00156,002#BAUDRATE#9600#PARITY#NONE# */void DEVICE_PARAMETER_CONFIGURATION(char *Data_From_Sub_Topic) {				char *pointer=NULL;	bool Valid_setting_rcv_flag = 0, Reset_Contoller_Flag = 0;	char String_array[2000]={0};           // considering length of the 99 queries from * to # the length will be 1700 approximately.		u8 device_id_rcv1[15]="";	int i = 0;	int SETTING_FLAG = 0;	    //strcpy(Buffer_Array,Data_From_Sub_Topic); //copy the data from one to another		/*ststr fn finds the common string and returns the address of the first alphabet of the string,	and store the whole string from return pointer onwards.*/		pointer= Ql_strstr(Data_From_Sub_Topic, DEVICE_ID);	if(pointer)                            	{                                     				//50150847#1#MODADD#03#001,3,00100,020#001,3,00134,016#001,3,00156,002#BAUDRATE#9600#PARITY#NONE#        // breaks the Device ID from the string and store in pointer and remaining store in NULL.				pointer=strtok(Data_From_Sub_Topic,"#"); 	    //we got a device ID		// remaining string is 1#MODADD#03#001,3,00100,020#001,3,00134,016#001,3,00156,002#BAUDRATE#9600#PARITY#NONE#		//copy the device ID from pointer to device_id_rcv1.		strcpy(device_id_rcv1,pointer); 		APP_DEBUG("<-- The Received device ID is: %s-->\r\n", device_id_rcv1);	 		for(i=0; i<15; i++) 		{			if((device_id_rcv1[i] >= 48) && (device_id_rcv1[i] <= 57))  // 48 is an ASCII value of 0 and 57 is an ASCII value of 9			{				DEVICE_ID[i] = device_id_rcv1[i] ;				SETTING_FLAG = 1;				APP_DEBUG("<-- The value of the setting flag is %d -->\r\n",SETTING_FLAG);			}		//	else{APP_DEBUG("<-- Invalid Device ID -->\r\n");}			if(device_id_rcv1[i] == '\0'){break;}		}		APP_DEBUG("<---DEVICE ID: %s --->\r\n",DEVICE_ID); 				if(SETTING_FLAG == 1)		{			SETTING_FLAG = 0;			//copy new received ID to device ID to be store			strcpy(DEVICE_ID,device_id_rcv1);			WRITE_DATA_TO_UFS(4, DEVICE_ID);						//copy the entire string to the pointer			pointer=strtok(NULL,"");						//remaining string is 1#MODADD#03#001,3,00100,020#001,3,00134,016#001,3,00156,002#BAUDRATE#9600#PARITY#NONE#						if(((*pointer=='1') || (*pointer=='2') || (*pointer=='3') || (*pointer=='4')) && (*(pointer+1)=='#'))			{				meter_no= (*pointer - 48);			//	APP_DEBUG("<-- Meter No is %d -->\r\n",meter_no);								//remove the meter no from the string				pointer=strtok(pointer,"#");								//remaining string is MODADD#03#001,3,00100,020#001,3,00134,016#001,3,00156,002#BAUDRATE#9600#PARITY#NONE#								pointer=strtok(NULL,"#");										//remaining string is 03#001,3,00100,020#001,3,00134,016#001,3,00156,002#BAUDRATE#9600#PARITY#NONE#								pointer=strtok(NULL,"");								//copy the entire string into string array				memset(String_array,0x00,sizeof(String_array));				strcpy(String_array,pointer);								switch(meter_no)				{										case 1: APP_DEBUG("<------------------------------------------------------\r\n");							APP_DEBUG("<------------------------------------------------------\r\n");							WRITE_DATA_TO_UFS(15, String_array);							APP_DEBUG("<--Configuration successfully saved in File no 15-->/r/n");							MODBUS_STORE_PARAMETER_DETECTECTION_FLAG = 1;							break;												case 2: APP_DEBUG("<------------------------------------------------------\r\n");							APP_DEBUG("<------------------------------------------------------\r\n");							WRITE_DATA_TO_UFS(16, String_array);							APP_DEBUG("<--Configuration successfully saved in File no 16-->/r/n");							MODBUS_STORE_PARAMETER_DETECTECTION_FLAG = 1;							break;																				case 3: APP_DEBUG("<------------------------------------------------------\r\n");							APP_DEBUG("<------------------------------------------------------\r\n");							WRITE_DATA_TO_UFS(17, String_array);							APP_DEBUG("<--Configuration successfully saved in File no 17-->/r/n");							MODBUS_STORE_PARAMETER_DETECTECTION_FLAG = 1;							break;												case 4: APP_DEBUG("<------------------------------------------------------\r\n");							APP_DEBUG("<------------------------------------------------------\r\n");							WRITE_DATA_TO_UFS(18, String_array);							APP_DEBUG("<--Configuration successfully saved in File no 18-->/r/n");							MODBUS_STORE_PARAMETER_DETECTECTION_FLAG = 1;							break;													default: 					break;												}											}			APP_DEBUG("<-- Range should be in between 0 to 4-->\r\n");			}				}			   				    else	{	   APP_DEBUG("<--INVALID STRING-->\r\n");    }	      	pointer= Ql_strstr(String_array, "BAUDRATE"); //BAUDRATE#9600#PARITY#NONE#	if(pointer)	{		char *r=NULL;		bool baudrate_valid_flag = 0;		u32 temp_baudrate=0;						r = Ql_strstr(pointer,"4800");		if(r)		{			baudrate_valid_flag = 1;			temp_baudrate = 4800;   //			APP_DEBUG("<--The Receive Baudrate is 4800b/s -->\r\n");		}						r = Ql_strstr(pointer,"9600");		if(r)		{			baudrate_valid_flag = 1;			temp_baudrate = 9600;			APP_DEBUG("<-- The Receive Baudrate is 9600b/s -->\r\n"); 		}				r = Ql_strstr(pointer,"19200");		if(r)		{			baudrate_valid_flag = 1;			temp_baudrate = 19200;			APP_DEBUG("<-- The Receive Baudrate is 19200b/s -->\r\n");		}				r = Ql_strstr(pointer,"38400");		if(r)		{			baudrate_valid_flag = 1;			temp_baudrate = 38400;			APP_DEBUG("<-- The Receive Baudrate is 38400b/s -->\r\n");		}				r = Ql_strstr(pointer,"57600");		if(r)		{			baudrate_valid_flag = 1;			temp_baudrate = 57600;			APP_DEBUG("<-- The Receive Baudrate is 57600b/s -->\r\n");		}				r = Ql_strstr(pointer,"115200");		if(r)		{			baudrate_valid_flag = 1;			temp_baudrate = 115200;			APP_DEBUG("<-- The Receive Baudrate is 115200b/s -->\r\n");		}				if(baudrate_valid_flag == 1)		{			{				char Stored_Array[150];								APP_DEBUG("<-- Existing baudrate is %ld", port2_dcb.baudrate);				port2_dcb.baudrate = temp_baudrate;				APP_DEBUG("<-- The new baudrate is %ld", port2_dcb.baudrate);					Ql_sprintf(Stored_Array,"SLAVE-ID:%03d,BAUDRATE:%06d,PARITY:%d,PROJ-NAME:%s,\0", MODBUS_SLAVE_ID, port2_dcb.baudrate, port2_dcb.parity, MODEL_NAME);				WRITE_DATA_TO_UFS(1, Stored_Array);							Reset_Contoller_Flag = 1;			}			//else{APP_DEBUG("<-- END OF THE MSG NOT MATCH\r\n");}		}		else{APP_DEBUG("<-- BAUDRATE INVALID\r\n");}	}	//03#001,3,00100,020#001,3,00134,016#001,3,00156,002#BAUDRATE#9600#PARITY#NONE#	pointer= Ql_strstr(String_array, "PARITY");	if(pointer)	{		char *r=NULL;		bool parity_valid_flag=0;		char temp_parity;				r = Ql_strstr(pointer,"NONE");		if(r)		{		  parity_valid_flag = 1;		  temp_parity = 0;		  APP_DEBUG("<-- The Receive Parity is None -->\r\n");		}				r = Ql_strstr(pointer,"ODD");		if(r)		{		  parity_valid_flag = 1;		  temp_parity = 1;		  APP_DEBUG("<-- The Receive Parity is ODD -->\r\n");		}				r = Ql_strstr(pointer,"EVEN");		if(r)		{		  parity_valid_flag = 1;		  temp_parity = 2;		  APP_DEBUG("<-- The Receive Parity is EVEN -->\r\n");		}				if(parity_valid_flag == 1)		{			//if(m_Read_Buffer[rdLen - 1] == '#')			{				char Stored_Array[150];				APP_DEBUG("<-- The existing parity is: %ld \r\n", port2_dcb.parity);				port2_dcb.parity = temp_parity;				APP_DEBUG("<-- The New parity is %ld \r\n", port2_dcb.parity);								Ql_sprintf(Stored_Array,"SLAVE-ID:%03d,BAUDRATE:%06d,PARITY:%d,PROJ-NAME:%s,\0", MODBUS_SLAVE_ID, port2_dcb.baudrate, port2_dcb.parity, MODEL_NAME);				WRITE_DATA_TO_UFS(1, Stored_Array);							//Ql_Reset(1000);				Reset_Contoller_Flag = 1;			}			//else{APP_DEBUG("<-- END OF THE MSG NOT MATCH\r\n");}		}		else{APP_DEBUG("<-- PARITY INVALID\r\n");}			}	if(Valid_setting_rcv_flag == 0)	{		APP_DEBUG("<-- INVALID KEYWORD FOR SETTING, EXIT FROM SETTING MODE\r\n");	}		else{APP_DEBUG("<-- COMPLETE OPERATION AS PER THE COMMAND, EXIT FROM SETTING MODE\r\n")}		if(Reset_Contoller_Flag == 1)	{		/*APP_DEBUG("<-- CONTROLLER WILL RESET IN 1000 ms \r\n");		Ql_Reset(1000); */		APP_DEBUG("<-- CONTROLLER WILL RESET IN 10000 ms \r\n");		Ql_Reset(1000);	}}void TIMER_HANDLER_SUBTASK1(u32 timerId, void* param){	s32 iRet = 0;		s32 ret;	//*((s32*)param) +=1;    switch(timerId)	{		case Stack_timer: 						APP_DEBUG("<-- DATA SEND TO SERVER -->\r\n");						send_flag1 = 1;						send_flag2= 1;						QUERY_SEND_STAGE = 0;						SEND_DATA_TO_SERVER_FLAG = 1;					//	APP_DEBUG("<-- SEND_DATA_TO_SERVER_FLAG = %d\r\n",SEND_DATA_TO_SERVER_FLAG);						PORT2_COMMUNICATION_FLAG=1;						QUERY_POINTER = 0; 						QUERY_RCV_POINTER = 0;						ERROR_STATUS_1=0; ERROR_STATUS_2=0; ERROR_STATUS_3=0; ERROR_STATUS_4=0; ERROR_STATUS_5=0; ERROR_STATUS_6=0; ERROR_STATUS_7=0; ERROR_STATUS_8=0; ERROR_STATUS_9=0; ERROR_STATUS_10=0; ERROR_STATUS_11=0; ERROR_STATUS_12=0;						comm_flag = 1;						GET_Present_Time();						NO_OF_MODBUS_VARIABLE_COUNT = 0;																		/*	Ql_memset(DATA_FROM_CONTROLLER, 0x00, sizeof(DATA_FROM_CONTROLLER));						Ql_memset(UTC_DATE_TIME_1, 0x0, sizeof(UTC_DATE_TIME_1));						Ql_strcpy(UTC_DATE_TIME_1, UTC_DATE_TIME);       */												Ql_memset(DATA_FROM_CONTROLLER, 0x00, sizeof(DATA_FROM_CONTROLLER));						Ql_memset(UTC_DATE_TIME_1, 0x0, sizeof(UTC_DATE_TIME_1));						Ql_strcpy(UTC_DATE_TIME_1, UTC_DATE_TIME);											ST_Interval_3 = (NO_OF_QUERY * ST_Interval_2) + 300; 						ret = Ql_Timer_Start(Stack_timer3,ST_Interval_3,FALSE); 						if(ret < 0)						{							APP_DEBUG("<-- Failed!! GP-timer Ql_Timer_Start fail, ret=%d-->\r\n",ret);						}	                					//	APP_DEBUG("<-- GP-timer Ql_Timer_Start(ID=%d,Interval=%d) ret=%d-->\r\n",Stack_timer3,ST_Interval_3,ret);					//    APP_DEBUG("<-- Timer start for %d msec -->\r\n", ST_Interval_3);						MODBUS_READ_QURIES();						break;								case Stack_timer2:					//	APP_DEBUG("<-- Modbus Query Delay Timer Start for %d msec -->\r\n", ST_Interval_2);						ret = Ql_Timer_Stop(Stack_timer2);						if(ret < 0)						{							  APP_DEBUG("<--failed!! stack MODBUS QUERY DELAY TIMER Stop ret=%d-->\r\n",ret);           						}					//	APP_DEBUG("\r\n<-- Modbus Query Delay Timer Stop -->\r\n");  						MODBUS_READ_QURIES();						break;			case Stack_timer3:					//	APP_DEBUG("<-- GPRS Time Out Timer Start\r\n\n");						ret = Ql_Timer_Stop(Stack_timer3);						if(ret < 0)						{							  APP_DEBUG("<--failed!! stack timer Ql_Timer_Stop ret=%d-->\r\n",ret);           						}					//	APP_DEBUG("<--GPRS Timer Stop(ID=%d,) ret=%d-->\r\n",Stack_timer2,ret);   						if(comm_flag == 1)						{						//	APP_DEBUG("<-- No communication with controller -->\r\n");							NO_COMMUNICATION_WITH_CONTROLLER_INDICATION = 0;							comm_flag = 0;							send_flag1 = 0;							//Ql_GPIO_SetLevel(MODBUS_PATH_SELECTION_PIN, PINLEVEL_HIGH);							NO_COMM_WITH_CONTROLLER_COUNT++;							if(NO_COMM_WITH_CONTROLLER_COUNT > 3)							{								COMMUNICATION_WITH_CONTROLLER_FLAG = 0;							}							else							{								COMMUNICATION_WITH_CONTROLLER_FLAG = 1;							}							APP_DEBUG("\r\n<-- No communication with controller -->\r\n");							if(SERVER_PROTOCOL_SELECTION == 1)							{								if(start_flag == 0)								{										PAYLOAD_FORMATION_FOR_SENDING(NO_COMM_WITH_CONTROLLER_PACKET);									SendEvent2SubTask(MSG_ID_USER_DATA, 0, 0);								}								else{//CREATE_AND_STORE_MODBUS_DATA(NO_COMM_WITH_CONTROLLER_PACKET);								}								//iRet = Ql_OS_SendMessage(subtask1_id,msgId,iData1, iData2);							}							else if(SERVER_PROTOCOL_SELECTION == 2)							{								if(socket_flag == 1)// checking GPRS connection is establish or not								{								//	APP_DEBUG("\r\n socket flag = 1 \r\n");								//	APP_DEBUG("\r\n Trying to get gprs connection \r\n");   									GPRS_TCP_Program(CREATE_CONNECTION_PACKET);								}								else								{									APP_DEBUG("\r\n GPRS connection is ok checking for going for socket connection or data sending \r\n");   									if(SOCKET_IN_WOULD_BLOCK_FLAG == 0)// checking socket is in would block condition or not									{										APP_DEBUG("\r\n socket not in would block loop \r\n");										APP_DEBUG("<-- m_SocketConnState = %d\r\n",m_SocketConnState);										if(m_SocketConnState > 0)//socket connection establish or not										{											APP_DEBUG("\r\n  socket is connected going for data send \r\n");											GPRS_TCP_Program(NO_COMM_WITH_CONTROLLER_PACKET);// if gprs connected and socket is connected go for data send										}										else										{											APP_DEBUG("\r\n  socket is not connected going for socket connection \r\n");											SOC_CONNECT_TO_SERVER();// if gprs connected and socket is not connected go for socket connection										}									}									else{ APP_DEBUG("\r\n socket in would block loop \r\n");  }																}							}							else{APP_DEBUG("<-- SERVER PROTOCOL SELECTION IS WRONG \r\n")}						}						break;				default: break;	}}void TIMER_HANDLER(u32 timerId, void* param){	s32 iRet = 0;		s32 ret;	//*((s32*)param) +=1;    switch(timerId)	{		case TIMER_ID_WATCHDOG_FEED:						COUNT_FOR_STORE_TIME_IN_UFL++;						if(start_flag == 0)						{							if(SYSTEM_WATCHDOG_FLAG == 1)							{								SYSTEM_WATCHDOG_FLAG = 0;								//if(COMMUNICATION_WITH_CONTROLLER_FLAG == 1)								{									s32* WTD_Id = (s32*)param;									Ql_WTD_Feed(*WTD_Id);								//	APP_DEBUG("<-- WATCHDOG FEED -->\r\n");									COUNT_FOR_STORE_TIME_IN_UFL = 0;								}								//else{APP_DEBUG("\r\n COMMUNICATION_WITH_CONTROLLER_FLAG IS OFF");}							}						//	else{APP_DEBUG("<-- WATCHDOG TIMER TRIGGER\r\n");}						}												if(COUNT_FOR_STORE_TIME_IN_UFL >= 95)						{							if(INITIAL_RTC_TIME_SYNC_FLAG == 1)							{								STORE_TIME_TO_MEMORY();							}							else{APP_DEBUG("<-- RTC TIME IS NOT INITALIZE\r\n");}						}						break;		case GP_timer:						//	APP_DEBUG("<-- Configuring....\r\n\n");						if(fota_flag == 1)						{							FOTA_upgrade();						}						else						{							//MODBUS_READ_QURIES();						}						break;			case Stack_timer4:						APP_DEBUG("<-- MODBUS QUERY WRITE TIMER\r\n\n");						if(send_flag1 == 0)						{							MODBUS_WRITE_FLAG = 1;							MODBUS_WRITE_QUERIES();						}						else						{							APP_DEBUG("<-- Sending Flag is SET\r\n");						}						break;		case LOGBOOK_TIMER:						APP_DEBUG("<-- LOGBOOK TRIGGER TIMER -->\r\n\n");						LOGBOOK_DATA_FLAG = 1;						APP_DEBUG("<-- LOGBOOK_DATA_FLAG = %d\r\n", LOGBOOK_DATA_FLAG);								break;								case Fota_Reset_Timer:						APP_DEBUG("<-- FOTA TIMER-->\r\n\n");						APP_DEBUG("<-- RESET SYSTEM-->\r\n");						FOTA_STATUS_VARIABLE.SUCCESS_STATUS = 0;												char status_array[50];												Ql_memset(status_array,0,sizeof(status_array));						Ql_sprintf(status_array,"%s,%d,%d\0",FOTA_STATUS_VARIABLE.MOBILE_NO,FOTA_STATUS_VARIABLE.TRIGGER_STATUS,FOTA_STATUS_VARIABLE.SUCCESS_STATUS);						APP_DEBUG("<-- FOTA STATUS = %s\r\n", status_array);						WRITE_DATA_TO_UFS(12, status_array);						Ql_Reset(3000);						break;								case MQTT_TIMER_ID:					//	APP_DEBUG("<-- MQTT TIMER \r\n");						switch(m_mqtt_state)						{        							case STATE_NW_QUERY_STATE:							{								s32 cgreg = 0;								//ret = RIL_NW_GetGPRSState(&cgreg);								//APP_DEBUG("//<Network State:cgreg = %d\r\n",cgreg);								//if((cgreg == NW_STAT_REGISTERED)||(cgreg == NW_STAT_REGISTERED_ROAMING))								//{									//<Set PDP context 0									RIL_NW_SetGPRSContext(0);								//	APP_DEBUG("//<Set PDP context 0 \r\n");									//<Set APN									RIL_NW_SetAPN(1, APN_NAME, APN_USERID, APN_PASSWD);								//	APP_DEBUG("//<Set APN \r\n");									//PDP activated									ret = RIL_NW_OpenPDPContext();									if(ret == RIL_AT_SUCCESS)									{								//		APP_DEBUG("//<Activate PDP context,ret = %d\r\n",ret);										m_mqtt_state = STATE_MQTT_CFG;										Location_Program();									}								//}								break;							}							case STATE_MQTT_CFG:							{								//ret = RIL_MQTT_QMTCFG_Ali(connect_id,product_key,device_name,device_secret);//<This configuration is required to connect to Ali Cloud.								RIL_MQTT_QMTCFG_Showrecvlen(connect_id,ShowFlag_1);//<This sentence must be configured. The configuration will definitely succeed, so there is no need to care about.								ret = RIL_MQTT_QMTCFG_Version_Select(connect_id,Version_3_1_1); 								if(RIL_AT_SUCCESS == ret)								{									//APP_DEBUG("//<Ali Platform configure successfully\r\n");									APP_DEBUG("<-- Select version 0.0.1 successfully -->\r\n");									m_mqtt_state = STATE_MQTT_OPEN;								}								else								{									//APP_DEBUG("//<Ali Platform configure failure,ret = %d\r\n",ret);									APP_DEBUG("//<Select version 0.0.1 failure,ret = %d\r\n",ret);								}								break;							}							case STATE_MQTT_OPEN:							{							 //	APP_DEBUG("<-- HOST_NAME:%s , HOST_PORT: %d -->\r\n",HOST_NAME, HOST_PORT);								ret = RIL_MQTT_QMTOPEN(connect_id,HOST_NAME,HOST_PORT);								if(RIL_AT_SUCCESS == ret)								{									APP_DEBUG("<-- Start opening a MQTT client -->\r\n");									if(FALSE == CLOSE_flag)										CLOSE_flag = TRUE;									m_mqtt_state = STATE_MQTT_TOTAL_NUM;								}								else								{									APP_DEBUG("<-- Open a MQTT client failure -->\r\n");								}								break;							}							case STATE_MQTT_CONN:							{								ret = RIL_MQTT_QMTCONN(connect_id,DEVICE_ID,username,passwd);								if(RIL_AT_SUCCESS == ret)								{									APP_DEBUG("<-- Start connecting to MQTT server -->\r\n");									if(FALSE == DISC_flag)										DISC_flag = TRUE;									m_mqtt_state = STATE_MQTT_TOTAL_NUM;								}								else								{									APP_DEBUG("<-- connect to MQTT server failure --> \r\n");								}								break;							}							case STATE_MQTT_SUB:							{												mqtt_topic_info_t.count = NO_OF_SUB_TOPIC;														for(char i=0; i< mqtt_topic_info_t.count; i++)								{									mqtt_topic_info_t.topic[i] = (u8*)Ql_MEM_Alloc(sizeof(u8)*256);									Ql_memset(mqtt_topic_info_t.topic[i],0,256);									Ql_memcpy(mqtt_topic_info_t.topic[i],test_topic_SUB_array[i],Ql_strlen(test_topic_SUB_array[i]));									mqtt_topic_info_t.qos[i] = QOS2_AT_EXACTLY_ONECE;								}															sub_message_id++;  //< 1-65535.																ret = RIL_MQTT_QMTSUB(connect_id,sub_message_id,&mqtt_topic_info_t);																for(char i=0; i< mqtt_topic_info_t.count; i++)								{									Ql_MEM_Free(mqtt_topic_info_t.topic[i]);									mqtt_topic_info_t.topic[i] = NULL;								}																if(RIL_AT_SUCCESS == ret)								{									APP_DEBUG("<-- Start subscribing topic -->\r\n");									m_mqtt_state = STATE_MQTT_TOTAL_NUM;								}								else								{									APP_DEBUG("<-- Subscribe topic failure -->\r\n");								}																SET_SUB_TOPIC_DETAILS();								break;							}							case STATE_MQTT_PUB:							{								/*APP_DEBUG("<-- ENTER TO TIMER CASE PUB\r\n");   // comments made by CP								pub_message_id++;  //< The range is 0-65535. It will be 0 only when<qos>=0.								ret = RIL_MQTT_QMTPUB(connect_id,pub_message_id,QOS1_AT_LEASET_ONCE,0,test_topic,Ql_strlen(test_data),test_data);								if(RIL_AT_SUCCESS == ret)								{									APP_DEBUG("//<Start publish a message to MQTT server\r\n");									m_mqtt_state = STATE_MQTT_TOTAL_NUM;								}								else								{									APP_DEBUG("//<Publish a message to MQTT server failure,ret = %d\r\n",ret);								}*/																ret = Ql_Timer_Stop(MQTT_TIMER_ID);								if(ret < 0)								{									  APP_DEBUG("\r\n<--failed!! stack timer Ql_Timer_Stop ret=%d-->\r\n",ret);           								}							//	APP_DEBUG("\r\n<-- MQTT Timer stop -->\r\n"); 																//s_iPassTask = subtask1_id;								if(fota_flag == 0)								{									iRet = Ql_OS_SendMessage(subtask1_id,MSG_ID_UART_AND_TIMER_INIT,0, 0);									if(iRet <0)									{										APP_DEBUG("\r\n<--failed!!, Ql_OS_SendMessage(1, %d, %d) fail,  ret=%d-->\r\n", 0, 0, iRet);									}								//	APP_DEBUG("\r\n<--Ql_OS_SendMessage(%d, %d, %d) ret=%d-->\r\n",MSG_ID_USER_DATA,0, 0, iRet);								}else{APP_DEBUG("<-- FOTA FLAG IS TRIGGER\r\n");}																break;							}						/*	case STATE_MQTT_TOTAL_NUM:							{								//<do nothing								APP_DEBUG("<-- Configuring...\r\n");								break;							}  */														default:							break;						}						break;							default:break;	}}void callback_onTimer(u32 timerId, void* param){    s32* wtdid;    s32 ret;    wtdid = (s32*)param;    //APP_DEBUG("<--multitask: callback_onTimer1 wtdid =%d -->\r\n",*wtdid);       		if(LOGIC_WTD3_TMR_ID == timerId)    {		if(SYSTEM_WATCHDOG_FLAG == 1)		{			Ql_WTD_Feed(*wtdid);			SYSTEM_WATCHDOG_FLAG = 0 ;			APP_DEBUG("\n watchdog feed, watchdog flag = 0 \n");			 //APP_DEBUG("<--multitask: callback_onTimer3 wtdid =%d, timerID =%d -->\r\n",*wtdid, timerId);      		}	}	else if((LOGIC_WTD1_TMR_ID == timerId) || (LOGIC_WTD2_TMR_ID == timerId))     {		if(SYSTEM_INITIALIZE_WATCHDOG_FLAG == 1)		{			Ql_WTD_Feed(*wtdid);			Ql_WTD_Stop(*wtdid);			Ql_Timer_Stop(timerId);			SYSTEM_INITIALIZE_WATCHDOG_FLAG = 0 ;			//APP_DEBUG("<--multitask: callback_onTimer1 or 2 wtdid =%d, timerID =%d -->\r\n",*wtdid, timerId);    						wtdid2 = Ql_WTD_Start(420*1000);			ret = Ql_Timer_Register(LOGIC_WTD3_TMR_ID, callback_onTimer, &wtdid2);			if(ret < 0)			{				APP_DEBUG("<--main task: register fail ret=%d-->\r\n",ret);			}			else			{				APP_DEBUG("<--main task: watchdog set",ret);			}			ret = Ql_Timer_Start(LOGIC_WTD3_TMR_ID, 65000 ,TRUE);						if(ret < 0)			{				APP_DEBUG("<--main task: start timer fail ret=%d-->\r\n",ret);        			   // return;			}			else			{				APP_DEBUG("<--main task: watchdog timer set",ret);			}			APP_DEBUG("<--main task: start timer OK  ret=%d-->\r\n",ret);		}	}}void STORE_TIME_TO_MEMORY(){	ST_Time* pTime = NULL;	u32 ret;	char STORE_TIME[8], STORE_DATE[8], STORE_TO_MEMORY[20];		Ql_memset(STORE_TIME,0,sizeof(STORE_TIME));	Ql_memset(STORE_DATE,0,sizeof(STORE_DATE));	Ql_memset(STORE_TO_MEMORY,0,sizeof(STORE_TO_MEMORY));		ret = Ql_GetLocalTime(&time);	 //   APP_DEBUG("\r\n<-- Local rtc_time successfully determined: %i.%i.%i %i:%i:%i timezone=%i-->\r\n", time.day, time.month,time.year, time.hour,time.minute, time.second,time.timezone);	  APP_DEBUG("\r\n<-- Local rtc_time successfully determined: %i.%i.%i %i:%i:%i -->\r\n", time.day, time.month,time.year, time.hour,time.minute, time.second);		Ql_sprintf(STORE_TIME,"%02d%02d%02d\0", time.hour, time.minute, time.second);	Ql_sprintf(STORE_DATE,"%02d%02d%02d\0", time.day, time.month, (time.year-2000));	Ql_sprintf(STORE_TO_MEMORY,"$%s%s#\0",STORE_TIME, STORE_DATE);	//	APP_DEBUG("<-- DATA STORE TO TIME FILE: %s\r\n",STORE_TO_MEMORY);		WRITE_DATA_TO_UFS(2,STORE_TO_MEMORY);}s32 Sync_NetworkTime(){	s32 ret = RIL_AT_SUCCESS;    char strAT[20];	    // Ql_sprintf(strAT, "AT+CTZU=2\n");    Ql_sprintf(strAT, "AT+QLTS\n");    ret = Ql_RIL_SendATCmd(strAT,Ql_strlen(strAT),ATResponse_Sync_NetworkTime_handler,NULL,0);  //  APP_DEBUG("<-- Send AT:%s, ret = %d -->\r\n",strAT, ret);    APP_DEBUG("<-- Sending network Sync time Command -->\r\n");		    if(RIL_AT_SUCCESS != ret)    {        APP_DEBUG("\r\n<-- send AT command failure -->\r\n");        return ret;    }    return ret;}void GET_Present_Time(){	ST_Time rtc_pTime;	ST_Time* pTime = NULL;	u32 ret;	u64 totalSeconds;	u8 i, temp[11]={0};	u16 present_min=0;	ret = Ql_GetLocalTime(&time);	//if((Ql_GetLocalTime(&rtc_time)))    //{        APP_DEBUG("\r\n<-- Local rtc_time successfully determined (UTC): %i.%i.%i %i:%i:%i timezone=%i -->\r\n", time.day, time.month,time.year, time.hour,time.minute, time.second,time.timezone);		//IST=UTC+5:30				totalSeconds= Ql_Mktime(&time);	//	APP_DEBUG("\r\n<-- Mktime is %lld -->\r\n", totalSeconds);				totalSeconds = totalSeconds + 19800;		                   		pTime = Ql_MKTime2CalendarTime(totalSeconds, &rtc_pTime);		if(NULL == pTime)		{			 APP_DEBUG("<-- Ql_MKTime2CalendarTime failed !! -->\r\n");		}		else		{			APP_DEBUG("\r\n<-- Current Time is: (%i.%i.%i %i:%i:%i timezone=%i)-->\r\n\r\n", rtc_pTime.day, rtc_pTime.month, rtc_pTime.year, rtc_pTime.hour, rtc_pTime.minute, rtc_pTime.second,rtc_pTime.timezone);		}		Ql_memset(UTC_DATE_TIME, 0x00, sizeof(UTC_DATE_TIME));				Ql_sprintf(UTC_DATE_TIME,"%04d%02d%02d%02d%02d%02d\0",rtc_pTime.year, rtc_pTime.month, rtc_pTime.day, rtc_pTime.hour, rtc_pTime.minute, rtc_pTime.second);	//}}static s32 ATResponse_Sync_NetworkTime_handler(char* line, u32 len, void* userdata){	// APP_DEBUG("QLTS Resp Line : %s\r\n", line);	char *head = Ql_RIL_FindString(line, len, "\r\n+QLTS: ");	if(head)	{  		// APP_DEBUG("Head : %s\r\n", head);				Set_LocalTime(head);				return	RIL_ATRSP_SUCCESS;	}	head = Ql_RIL_FindString(line, len, "ERROR:");//fail	if(head)	{		return	RIL_ATRSP_FAILED;	}	head = Ql_RIL_FindString(line, len, "OK");    if(head)    {	        return  RIL_ATRSP_SUCCESS;    }      return RIL_ATRSP_CONTINUE; //continue wait}void Set_LocalTime(u8 *str){	int i=0, j=0;	s32 ret;	u8 buf_tmp[4] = {0};	bool add_gmt_flag = 1;	//ST_Time time;	//	APP_DEBUG("str = %s\r\n", str);		while(str[i] != '"'){		i++;	}		i++, j=0;	Ql_memset(buf_tmp, 0x0, sizeof(buf_tmp));	while(str[i] != '/'){		buf_tmp[j] = str[i];		i++, j++;	}	// APP_DEBUG("buf_tmp = %s\r\n", buf_tmp);	time.year = (2000 + atoi(buf_tmp));	// APP_DEBUG("time.year = %d\r\n", time.year);		i++, j=0;	Ql_memset(buf_tmp, 0x0, sizeof(buf_tmp));	while(str[i] != '/'){		buf_tmp[j] = str[i];		i++, j++;	}	// APP_DEBUG("buf_tmp = %s\r\n", buf_tmp);	time.month = atoi(buf_tmp);	// APP_DEBUG("time.month = %d\r\n", time.month);		i++, j=0;	Ql_memset(buf_tmp, 0x0, sizeof(buf_tmp));	while(str[i] != ','){		buf_tmp[j] = str[i];		i++, j++;	}	// APP_DEBUG("buf_tmp = %s\r\n", buf_tmp);	time.day = atoi(buf_tmp);	// APP_DEBUG("time.day = %d\r\n", time.day);		i++, j=0;	Ql_memset(buf_tmp, 0x0, sizeof(buf_tmp));	while(str[i] != ':'){		buf_tmp[j] = str[i];		i++, j++;	}	// APP_DEBUG("buf_tmp = %s\r\n", buf_tmp);	time.hour = atoi(buf_tmp);	// APP_DEBUG("time.hour = %d\r\n", time.hour);		i++, j=0;	Ql_memset(buf_tmp, 0x0, sizeof(buf_tmp));	while(str[i] != ':'){		buf_tmp[j] = str[i];		i++, j++;	}	// APP_DEBUG("buf_tmp = %s\r\n", buf_tmp);	time.minute = atoi(buf_tmp);	// APP_DEBUG("time.minute = %d\r\n", time.minute);		i++, j=0;	Ql_memset(buf_tmp, 0x0, sizeof(buf_tmp));	if(str[i+2] == '+')	{		while((str[i] != '+')){			buf_tmp[j] = str[i];			i++, j++;		}	}	else if(str[i+2] == '-')	{		while((str[i] != '-')){			buf_tmp[j] = str[i];			i++, j++;		}	}	// APP_DEBUG("buf_tmp = %s\r\n", buf_tmp);	time.second = atoi(buf_tmp);	// APP_DEBUG("time.second = %d\r\n", time.second);		j=0;	Ql_memset(buf_tmp, 0x0, sizeof(buf_tmp));	while(str[i] != ','){		buf_tmp[j] = str[i];		i++, j++;	}	// APP_DEBUG("buf_tmp = %s\r\n", buf_tmp);	//time.timezone = atoi(buf_tmp);	time.timezone = 0;//	APP_DEBUG("<-- time.timezone = %d -->\r\n ", time.timezone);	ret = Ql_SetLocalTime(&time);		// APP_DEBUG("<-- Set Local Time (%d.%02d.%02d %02d:%02d:%02d timezone=%02d)=%d -->\n\r",         // time.year, time.month, time.day, time.hour, time.minute, time.second, time.timezone, ret);			//get local time	if((Ql_GetLocalTime(&time)))	{		APP_DEBUG("<-- Get Local Time(%d.%02d.%02d %02d:%02d:%02d timezone=%02d)=%d -->\n\r", 			time.year, time.month, time.day, time.hour, time.minute, time.second, time.timezone, ret);	}	else	{		APP_DEBUG("\r\n<--failed !! Local time not determined -->\r\n");	}			INITIAL_RTC_TIME_SYNC_FLAG = 1;	STORE_TIME_TO_MEMORY();}int PORT_VALUE_CAL(char writeBuffer11[]){	int total=0, total1=0;	char i;	for(i=0; i< 5; i++)	{		if(writeBuffer11[i] == '\0')		{			break;		}		total = total * 10;		total1 = writeBuffer11[i] ;		total1 = total1 - 48 ;		total = total + total1;	}	return total;}u32 CONVERT_TIME_BUFFER_TO_SECONDS_VALUE(char interval_buf[]){	u32 sum=0; 	int sum1=0;		sum = interval_buf[0] - 48;	sum = sum * 10;	sum = sum + interval_buf[1] - 48;	sum = sum * 60 ; 	sum1 = interval_buf[3] - 48;	sum1 = sum1 * 10;	sum1 = sum1 + interval_buf[4] - 48;	sum = sum + sum1;	sum = sum * 1000;		return sum;}static void Location_Program(void){    s32 ret;    u8  pdpCntxtId;    // Set PDP context    ret = Ql_GPRS_GetPDPContextId();//    APP_DEBUG("<-- The PDP context id available is: %d (can be 0 or 1)-->\r\n", ret);    if (ret >= 0)    {        pdpCntxtId = (u8)ret;    }    ret = RIL_NW_SetGPRSContext(pdpCntxtId);//    APP_DEBUG("<-- Set PDP context id to %d -->\r\n", pdpCntxtId);    if (ret != RIL_AT_SUCCESS)    {        APP_DEBUG("<-- Ql_RIL_SendATCmd error  ret=%d-->\r\n",ret );    }    // Request to get location//    APP_DEBUG("<-- Getting module location... -->\r\n");    ret = RIL_GetLocation(Callback_Location);    if (ret != RIL_AT_SUCCESS)    {        APP_DEBUG("<-- Ql_GetLocation error  ret=%d-->\r\n",ret );    }	ret = Ql_GPRS_DeactivateEx(pdpCntxtId, TRUE); //   APP_DEBUG("<-- Deactivated GPRS, cause=%d -->\r\n\r\n", ret);}void Callback_Location(s32 result, ST_LocInfo* loc_info){    int string1, string2,i=0, k=0;	char test[50]={0},test1[50]={0};//	APP_DEBUG("\r\n<-- Module location: latitude=%f, longitude=%f -->\r\n", loc_info->latitude, loc_info->longitude);		DEVICE_LATITUDE  = loc_info->latitude;	DEVICE_LONGITUDE = loc_info->longitude;	//	APP_DEBUG("<-- DEVICE_LATITUDE: %8.5f ,DEVICE_LONGITUDE: %8.5f \r\n ",DEVICE_LATITUDE,DEVICE_LONGITUDE);		}static u32 m_rcvDataLen = 0;static void HTTP_RcvData(u8* ptrData, u32 dataLen, void* reserved){    APP_DEBUG("<-- Data coming on http, total len:%d -->\r\n", m_rcvDataLen + dataLen);    if ((m_rcvDataLen + dataLen) <= sizeof(arrHttpRcvBuf))    {        Ql_memcpy((void*)(arrHttpRcvBuf + m_rcvDataLen), (const void*)ptrData, dataLen);		APP_DEBUG("\r\n Data_Rcv_On_Http = %s", ptrData);    } else {        if (m_rcvDataLen < sizeof(arrHttpRcvBuf))        {// buffer is not enough            u32 realAcceptLen = sizeof(arrHttpRcvBuf) - m_rcvDataLen;            Ql_memcpy((void*)(arrHttpRcvBuf + m_rcvDataLen), (const void*)ptrData, realAcceptLen);            APP_DEBUG("<-- Rcv-buffer is not enough, discard part of data (len:%d/%d) -->\r\n", dataLen - realAcceptLen, dataLen);        } else {// No more buffer            APP_DEBUG("<-- No more buffer, discard data (len:%d) -->\r\n", dataLen);			APP_DEBUG("\r\n Data_Rcv_On_Http = %s", ptrData);        }    }    m_rcvDataLen += dataLen; }/* static void HTTP_Program(u8 http_action, char Data_Send_To_Server[]){    s32 ret,i;		u16 Data_Packet_Length;	Data_Packet_Length = strlen(Data_Send_To_Server);	STORE_DATA_LENGTH = Data_Packet_Length;		//APP_DEBUG("<-- Data_Packet_Length = %d\r\n",Data_Packet_Length);		if(HTTP_GPRS_SETTING_FLAG == 0)	{		APP_DEBUG("<-- GPRS SETTING\r\n");				// Set PDP context		ret = RIL_NW_SetGPRSContext(Ql_GPRS_GetPDPContextId());		APP_DEBUG("<-- Set GPRS PDP context, ret=%d -->\r\n", ret);					APP_DEBUG("<-- GPRS SETTING1 PASS\r\n");			// Set APN		ret = RIL_NW_SetAPN(1, APN_NAME, APN_USERID, APN_PASSWD);		APP_DEBUG("<-- Set GPRS APN, ret=%d -->\r\n", ret);		APP_DEBUG("<-- GPRS SETTING2 PASS\r\n");		// Open/Activate PDP context		ret = RIL_NW_OpenPDPContext();		APP_DEBUG("<-- Open PDP context, ret=%d -->\r\n", ret);				APP_DEBUG("<-- GPRS SETTING3 PASS\r\n");		if(ret == 0)		{			HTTP_GPRS_SETTING_FLAG = 1;		}	}else{APP_DEBUG("<-- GPRS SETTING ALREADY DONE\r\n");}		if(HTTP_RESPONSE_FLAG == 0)	{		// Set HTTP server address (URL)		ret = RIL_HTTP_SetServerURL(HTTP_URL_ADDR, Ql_strlen(HTTP_URL_ADDR));		APP_DEBUG("<-- Set http server URL-> %s, ret=%d -->\r\n",HTTP_URL_ADDR, ret);	}	else	{APP_DEBUG("<-- HTTP_RESPONSE_FLAG = %d\r\n",HTTP_RESPONSE_FLAG);}    // Send get/post request    m_rcvDataLen = 0;    if (0 == http_action)    {        // get-request        ret = RIL_HTTP_RequestToGet(60);   // 100s timetout        APP_DEBUG("<-- Send get-request, ret=%d -->\r\n", ret);        // Read response from server        ret = RIL_HTTP_ReadResponse(60, HTTP_RcvData);        APP_DEBUG("<-- Read http response data, ret=%d, dataLen=%d -->\r\n", ret, m_rcvDataLen);    }    else if (1 == http_action)    {        // post-request        ret = RIL_HTTP_RequestToPost(Data_Send_To_Server, Data_Packet_Length);//Ql_strlen((char*)Data_Send_To_Server));        APP_DEBUG("<-- Send post-request, postMsg=%s & ret=%d -->\r\n", (char*)Data_Send_To_Server, ret);		ret = -1;        // Read response from server        ret = RIL_HTTP_ReadResponse(30, HTTP_RcvData);        APP_DEBUG("<-- Read http response data, ret=%d, dataLen=%d -->\r\n", ret, m_rcvDataLen);		if(ret == 0)		{			NO_COMM_WITH_CONTROLLER_COUNT = 0;			COMMUNICATION_WITH_CONTROLLER_FLAG = 1;			SYSTEM_WATCHDOG_FLAG = 1; 			HTTP_RESPONSE_FLAG = 1;			HTTP_GPRS_SETTING_FLAG = 1;			if(DATA_STORE_FLAG == 1)			{				APP_DEBUG("<-- DATA_STORE_FLAG is On\r\n");					//SEND_STORE_DATA();			}		}		else		{			HTTP_RESPONSE_FLAG = 0;			//HTTP_GPRS_SETTING_FLAG = 0;			//DATA_STORE_FLAG = 1;			//STORE_DATA_STRING_TO_MEMORY(Data_Send_To_Server, STORE_DATA_LENGTH);		}    }    else if (2 == http_action){        //get-request        // ret = RIL_HTTP_RequestToGet(100);   // 100s timetout        // APP_DEBUG("<-- Send get-request, ret=%d -->\r\n", ret);        //Download file from http server        // ret = RIL_HTTP_DownloadFile(RAM_FILE_NAME, RAM_FILE_SIZE, Callback_HTTP_DwnldFile);        // APP_DEBUG("<-- Download file from http server, ret=%d -->\r\n", ret);    }    HTTP_BLOCK_STATE_FLAG = 0;    	// Close PDP context    //ret = RIL_NW_ClosePDPContext();    //APP_DEBUG("<-- Close PDP context, ret=%d -->\r\n", ret);}    */void STORE_DATA_STRING_TO_MEMORY(char *Data, int Store_Length){	u32 writenLen = 0;	s32 position = 0;    	s32 handle = -1;	u8 ret;						if(STORE_DATA_COUNT < 300)	{			STORE_DATA_COUNT++;	 		DATA_STORE_FLAG = 1;				ret = Ql_FS_Check(filePath3);		if(ret != QL_RET_OK)		{			APP_DEBUG("\r\n<--filepath=%s does not exist creat file! -->", filePath3);             		}				handle = Ql_FS_Open(filePath13,QL_FS_READ_WRITE |QL_FS_CREATE );		APP_DEBUG("\r\n<--!! Ql_FS_Open  handle =%d -->\r\n",handle);		APP_DEBUG("\r\n<--filepath=%s -->\r\n", filePath13);				Ql_FS_Flush(handle);       		ret = Ql_FS_Seek(handle,0,QL_FS_FILE_END);		APP_DEBUG("\r\n<--!! Ql_FS_Seek   ret =%d-->\r\n",ret);  				position = Ql_FS_GetFilePosition(handle);		APP_DEBUG("\r\n<--!! Ql_FS_GetFilePosition   position =%d-->\r\n",position);		ret = Ql_FS_Write(handle, Data, Store_Length, &writenLen);		APP_DEBUG("\r\n<--!! Ql_FS_Write  ret =%d  writenLen =%d-->\r\n",ret,writenLen);				Ql_FS_Flush(handle);		Ql_FS_Close(handle);		STORE_DATA_COUNT_TO_MEMORY();	}	else	{		APP_DEBUG("<-- STOREAGE IS FULL, 300 STRING ARE ALREADY STORED\r\n");            	}}STORE_DATA_COUNT_TO_MEMORY(){	char STORE_TO_MEMORY[40];		Ql_memset(STORE_TO_MEMORY, 0, sizeof(STORE_TO_MEMORY));	Ql_sprintf(STORE_TO_MEMORY,"STORE DATA COUNT:%05d#LENGTH:%05d#\0",STORE_DATA_COUNT, STORE_DATA_LENGTH);	APP_DEBUG("<--- DATA STORE TO TIME FILE: %s\r\n",STORE_TO_MEMORY);		WRITE_DATA_TO_UFS(9,STORE_TO_MEMORY);}CREATE_AND_STORE_MODBUS_DATA(char PACKET_TYPE){	s32 ret,i;	u16 Data_Packet_Length;	u8 START_OF_THE_STRING = '*',END_OF_THE_REQUEST_STRING = '^';	u8 START_OF_THE_MESSAGE[80], HTTP_POST_MSG[3000];	u8 DATA_STRING[6] = "DATA\0", COMMUNICATION_ERROR[6] = "CEWC\0", COMMUNICATION_ERR_PORT2[6] = "CEC1\0", COMMUNICATION_ERR_PORT3[6] = "CEC2\0"; 	u8 SLAVE_ID_START = 1, SLAVE_ID_END = 3;	    Ql_memset(HTTP_POST_MSG,0,sizeof(HTTP_POST_MSG));	Ql_memset(START_OF_THE_MESSAGE,0,sizeof(START_OF_THE_MESSAGE));		Ql_sprintf(START_OF_THE_MESSAGE,"%c,%s,%s,%s,%s,%08.5f,%08.5f\0",START_OF_THE_STRING, DEVICE_ID, MODEL_NAME, UTC_DATE_TIME, VERSION, DEVICE_LATITUDE, DEVICE_LONGITUDE);	if(DATA_PACKET == PACKET_TYPE)	{		Ql_sprintf(HTTP_POST_MSG, "%s,%03d,%s,%02d,%02d,%c,%s#\0",START_OF_THE_MESSAGE, ERROR_STATUS_1, DATA_STRING, SLAVE_ID_START, SLAVE_ID_END, END_OF_THE_REQUEST_STRING, DATA_FROM_CONTROLLER);				Data_Packet_Length = strlen(HTTP_POST_MSG);		STORE_DATA_LENGTH = Data_Packet_Length;	}	else if(PACKET_TYPE == NO_COMM_WITH_CONTROLLER_PACKET)	{		comm_flag = 0;		APP_DEBUG("\r\n<-- No Communication Data\r\n");		Ql_sprintf(HTTP_POST_MSG, "%s,%03d,%s,%02d,%02d,%c,%s#\0",START_OF_THE_MESSAGE, ERROR_STATUS_1, COMMUNICATION_ERROR, SLAVE_ID_START, SLAVE_ID_END, END_OF_THE_REQUEST_STRING, DATA_FROM_CONTROLLER);				Data_Packet_Length = strlen(HTTP_POST_MSG);		STORE_DATA_LENGTH = Data_Packet_Length;	}	//	APP_DEBUG("<-- Data_Packet_Length = %d\r\n",Data_Packet_Length);		if(INITIAL_RTC_TIME_SYNC_FLAG == 1)	{		DATA_STORE_FLAG = 1;	//	STORE_DATA_STRING_TO_MEMORY(HTTP_POST_MSG, STORE_DATA_LENGTH);		}	else{APP_DEBUG("<-- RTC TIME IS NOT SYNC\r\n");}}void SEND_STORE_DATA(){	APP_DEBUG("<-- Send Store Data Function\r\n");		if(STORE_DATA_COUNT > 0)	{		int i,j;		s32 ret = -1;		s32 handle = -1;		u8 strBuf[STORE_DATA_LENGTH+10];		u32 dataLen = STORE_DATA_LENGTH; 		u32 readenLen = 0;		s32 Negative_dataLen;		s32 position = 0;		char *p= NULL, *q = NULL;		Ql_memset(strBuf, 0, sizeof(strBuf));				Negative_dataLen = (-1 * STORE_DATA_LENGTH);		handle = Ql_FS_Open(filePath13,QL_FS_READ_WRITE |QL_FS_CREATE );		APP_DEBUG("\r\n<--!! Ql_FS_Open  handle =%d -->\r\n",handle);		Ql_FS_Flush(handle);				APP_DEBUG("<-- Defining Position\r\n");		ret = Ql_FS_Seek(handle, Negative_dataLen, QL_FS_FILE_END);		APP_DEBUG("<-- Position Defined\r\n");	//  handle = handle - dataLen;				//read file		ret = Ql_FS_Read(handle, strBuf, dataLen, &readenLen);		APP_DEBUG("\r\n<-- Ql_FS_Read() ret=%d: readedlen=%d, readBuffer=%s-->\r\n", ret, readenLen, strBuf);				ret = Ql_FS_Seek(handle, Negative_dataLen, QL_FS_FILE_END);		APP_DEBUG("\r\n<--!! Ql_FS_Seek   ret =%d-->\r\n",ret);		//get postion		position = Ql_FS_GetFilePosition(handle);		APP_DEBUG("\r\n<--!! Ql_FS_GetFilePosition   position =%d-->\r\n",position);		//truncate 		ret = Ql_FS_Truncate(handle);				//seek begin 		ret = Ql_FS_Seek(handle,0,QL_FS_FILE_BEGIN);		Ql_FS_Close(handle);		q = Ql_strstr(strBuf,"*,");		if(q)		{			p = Ql_strstr(strBuf,"DATA");					if(p)			{				char length;								length = p - q;								strBuf[length] = 'S'; strBuf[length+1] = 'T'; strBuf[length+2] = 'D'; strBuf[length+3] = 'T';			}			else			{				p = Ql_strstr(strBuf,"CEWC");				if(p)				{					char length;									length = p - q;										strBuf[length] = 'S'; strBuf[length+1] = 'T'; strBuf[length+2] = 'D'; strBuf[length+3] = 'T';				}				else{APP_DEBUG("<-- NOT MATCH COMMUNICATION TYPE\r\n");}			}		}		else		{			APP_DEBUG("<--START OF THE STRING IS NOT PRESENT IN A STORED STRING\r\n");		}				STORE_DATA_COUNT--; 				if(STORE_DATA_COUNT <= 0)		{			DATA_STORE_FLAG = 0;		}		APP_DEBUG("<-- STORE_DATA_COUNT = %d\r\n", STORE_DATA_COUNT);		STORE_DATA_COUNT_TO_MEMORY();			//	ret = RIL_HTTP_RequestToPost(strBuf, dataLen);//Ql_strlen((char*)HTTP_POST_MSG));   //   APP_DEBUG("<-- Send post-request, postMsg=%s & ret=%d -->\r\n", (char*)strBuf, ret);				s32 totalBytes;		totalBytes = Ql_strlen(strBuf);				ret = RIL_MQTT_QMTPUB(connect_id,pub_message_id,QOS1_AT_LEASET_ONCE,0,test_topic_BUF_array[0],totalBytes,strBuf);		if (RIL_AT_SUCCESS == ret)		{			APP_DEBUG("<-- The return value is %d -->\r\n",ret);			APP_DEBUG("<-- Publish store data sucessfully -->\r\n");		}		else		{			APP_DEBUG("<-- Publish message to server failed -->\r\n");		}	/*	ret = -1;        // Read response from server        ret = RIL_HTTP_ReadResponse(30, HTTP_RcvData);        APP_DEBUG("<-- Read http response data, ret=%d, dataLen=%d -->\r\n", ret, m_rcvDataLen); */	}	else	{		APP_DEBUG("<-- No Data in Memory -->\r\n");		DATA_STORE_FLAG = 0;	}}void MODBUS_RESPONSE_CHECK(char *Data,int Length){	int i;	s32 ret;	char my_char[1024], cal_length=0;	char Temp_Buffer_Modbus_Data[500];	bool FUNCTION_CODE_CONDITION_FAIL_FLAG = 0;		Ql_memset(Temp_Buffer_Modbus_Data, 0x00, sizeof(Temp_Buffer_Modbus_Data));		if(QUERY_RCV_POINTER == 0)	{		//Ql_memset(DATA_FROM_CONTROLLER, 0x00, sizeof(DATA_FROM_CONTROLLER));		NO_OF_MODBUS_VARIABLE_COUNT = 0;	}		if((FUNCTION_CODE[QUERY_RCV_POINTER] == 0x01) || (FUNCTION_CODE[QUERY_RCV_POINTER] == 0x02))	{		char temp_Var = 0; 						cal_length = MODBUS_LEGTH[QUERY_RCV_POINTER] ;		temp_Var = cal_length/8;		if(cal_length % 8)  //right		{			cal_length = (temp_Var + 1);		}		else{cal_length = temp_Var;}		}	else if((FUNCTION_CODE[QUERY_RCV_POINTER] == 0x03) || (FUNCTION_CODE[QUERY_RCV_POINTER] == 0x04))	{				cal_length = (MODBUS_LEGTH[QUERY_RCV_POINTER]) * 2;	}	else	{		DATA_RCV_ON_UART_FOR_MODBUS_FLAG = 0;		FUNCTION_CODE_CONDITION_FAIL_FLAG = 1;		//APP_DEBUG("<-- FUNCTION_CODE_CONDITION_FAIL_FLAG = %d",FUNCTION_CODE_CONDITION_FAIL_FLAG);	}		if(FUNCTION_CODE_CONDITION_FAIL_FLAG == 0)  ////right	{		if(Length == (cal_length + 5))		{		//	APP_DEBUG("<-- RESPONSE RCV VALID FOR QUREY NO: %d\r\n", (QUERY_RCV_POINTER+1));   			for(i = 0; i<(Length-5); i++)			{				Temp_Buffer_Modbus_Data[i] = Data[i+3];			}			CAPTURE_DATA_FOR_PAYLOAD(Temp_Buffer_Modbus_Data, cal_length, NORMAL_DATA);		}		else if(Length == (cal_length + 13))		{			APP_DEBUG("<-- RESPONSE RCV QUERY + VALID FOR QUREY NO: %d\r\n", (QUERY_RCV_POINTER+1));			for(i = 0; i<(Length-13); i++)			{				Temp_Buffer_Modbus_Data[i] = Data[i+11]; 			}			CAPTURE_DATA_FOR_PAYLOAD(Temp_Buffer_Modbus_Data, cal_length, NORMAL_DATA);		}		else		{       //right			APP_DEBUG("<-- RESPONSE RCV INVALID FOR QUREY NO: %d\r\n", (QUERY_RCV_POINTER+1));			for(i = 0; i < cal_length; i++)			{				Temp_Buffer_Modbus_Data[i] = 0x00; 			}			CAPTURE_DATA_FOR_PAYLOAD(Temp_Buffer_Modbus_Data, cal_length, ERROR_DATA);						char Error_Switch_Case_Pointer = 0, Error_Position_Pointer = 0, Error_Value= 0; 					Error_Switch_Case_Pointer = QUERY_RCV_POINTER/8;			Error_Position_Pointer = QUERY_RCV_POINTER % 8;						Error_Value = pow(2,Error_Position_Pointer);						switch(Error_Switch_Case_Pointer)			{				case 0:  ERROR_STATUS_1 = ERROR_STATUS_1 + Error_Value; break;				case 1:  ERROR_STATUS_2 = ERROR_STATUS_2 + Error_Value; break;				case 2:  ERROR_STATUS_3 = ERROR_STATUS_3 + Error_Value; break;				case 3:  ERROR_STATUS_4 = ERROR_STATUS_4 + Error_Value; break;				case 4:  ERROR_STATUS_5 = ERROR_STATUS_5 + Error_Value; break;				case 5:  ERROR_STATUS_6 = ERROR_STATUS_6 + Error_Value; break;				case 6:  ERROR_STATUS_7 = ERROR_STATUS_7 + Error_Value; break;				case 7:  ERROR_STATUS_8 = ERROR_STATUS_8 + Error_Value; break;				case 8:  ERROR_STATUS_9 = ERROR_STATUS_9 + Error_Value; break;				case 9:  ERROR_STATUS_10 = ERROR_STATUS_10 + Error_Value; break;				case 10: ERROR_STATUS_11 = ERROR_STATUS_11 + Error_Value; break;				case 11: ERROR_STATUS_12 = ERROR_STATUS_12 + Error_Value; break;				default: APP_DEBUG("\r\n CHECK CALCULATION FOR ERROR CASE"); break;			}		}         //right				if(QUERY_POINTER == 0)		{			comm_flag = 0;			PORT2_COMMUNICATION_FLAG = 0;			NO_COMMUNICATION_WITH_CONTROLLER_INDICATION = 1;			if(SERVER_PROTOCOL_SELECTION == 1)			{				if(start_flag == 0)				{					if(DATA_STRING_COUNTER == 0)					{						PAYLOAD_FORMATION_FOR_SENDING(DATA_PACKET);						SendEvent2SubTask(MSG_ID_USER_DATA, 0, 1);					}				}				else{//CREATE_AND_STORE_MODBUS_DATA(DATA_PACKET);				}			}			else if(SERVER_PROTOCOL_SELECTION == 2)			{				if(socket_flag == 1)   //right				{					APP_DEBUG("\r\n socket flag = 1 \r\n");					APP_DEBUG("\r\n Trying to get gprs onnection \r\n");   					GPRS_TCP_Program(CREATE_CONNECTION_PACKET);				}				else				{					APP_DEBUG("\r\n GPRS connection is ok checking for going for socket connection or data sending \r\n");   					if(SOCKET_IN_WOULD_BLOCK_FLAG == 0)					{						APP_DEBUG("\r\n socket not in would block loop \r\n");   						if(m_SocketConnState > 0)						{							APP_DEBUG("\r\n  socket is connected going for data send \r\n");							GPRS_TCP_Program(DATA_PACKET);						}						else						{							APP_DEBUG("\r\n  socket is not connected going for socket connection \r\n");							SOC_CONNECT_TO_SERVER();						}					}					else{ APP_DEBUG("\r\n socket in would block loop \r\n");  }								}			}			else{APP_DEBUG("<-- SERVER PROTOCOL SELECTION IS WRONG \r\n")}		}	}	else{ APP_DEBUG("<-- FUNCTION CODE CONDITION FAIL\r\n");}                             //right	int k;	Ql_memset(my_char,0,sizeof(my_char));	for(i = 0; i< (Length); i++)//convert hex data to ascii form	{		k= i*2;		my_char[k] = DECIMAL_TO_HEX(Data[i] / 0x10);		my_char[k+1] = DECIMAL_TO_HEX(Data[i] % 0x10);	}//	APP_DEBUG("DATA IN HEX => %s\r\n",my_char);			APP_DEBUG("\n\n");}void SEPARATE_MODBUS_DATA(char No_Of_Data, char write_mod[]){	char z, i2;	//int address_mod[84], data_mod[84];			APP_DEBUG("<-- MODBUS WRITE DATA = %s\r\n", write_mod);			APP_DEBUG("<-- NO. OF WRITE DATA = %d\r\n", No_Of_Data);			for(z=0 ;z <No_Of_Data; z++)	{				address_mod[z] = (((write_mod[(z*10)+1] - 48) *1000) + ((write_mod[(z*10)+2] - 48) *100) + ((write_mod[(z*10)+3] - 48) *10) + (write_mod[(z*10)+4] - 48));				data_mod[z] = (((write_mod[(z*10)+5] - 48) *10000) + ((write_mod[(z*10)+6] - 48) *1000) + ((write_mod[(z*10)+7] - 48) *100) + ((write_mod[(z*10)+8] - 48) *10) +(write_mod[(z*10)+9] - 48));				if(write_mod[z*10] ==  '1')		{			address_mod[z] = address_mod[z] +10000;		}		APP_DEBUG("<-- LOOP COUNT = %d \r \n ", z);			APP_DEBUG("<-- WRITE DATA = %d, WRITE ADDRESS = %d\r \n ", data_mod[z], address_mod[z]);				DELAY(200);			} 		for(z=0 ;z <No_Of_Data; z++)			{		APP_DEBUG("<-- DATA_TO_WRITE = %d , ADDRESS = %d\r\n", data_mod[z], address_mod[z]);		}	APP_DEBUG("<-- END POSSITION = %d\r\n", z);		}void WTD_Init(){	s32 ret;	// Initialize external watchdog:    ret = Ql_WTD_Init(0, WATCHDOG_FEED_PIN, Timer_Val_WatchdogFeed);	// 0 means external WTD, 1 Means internal WTD    if (0 == ret)    {		#if APP_DEBUG_ENABLE        APP_DEBUG("\r\n<-- Watchdog Init OK!-->\r\n");    		#endif		    }    // Create a logic watchdog, It feed the external watchdog for the interval.	// the interval is 30s (can keep 30s or 1min also)      WTD_Id = Ql_WTD_Start(1*60*1000);  		// Register & start a timer to feed the logic watchdog.    // The watchdog id will be passed into callback function as parameter.    ret = Ql_Timer_Register(TIMER_ID_WATCHDOG_FEED, TIMER_HANDLER, &WTD_Id);    if(ret < 0)    {		#if APP_DEBUG_ENABLE         APP_DEBUG("<-- Watchdog Timer register fail ret=%d -->\r\n",ret);		#endif        return;    }//	else{APP_DEBUG("<-- Watchdog Timer Register\r\n");}	   // ret = Ql_Timer_Start(TIMER_ID_WATCHDOG_FEED, 2000,TRUE);   ret = Ql_Timer_Start(TIMER_ID_WATCHDOG_FEED, 13000,TRUE);    if(ret < 0)    {		#if APP_DEBUG_ENABLE        APP_DEBUG("<-- Watchdog Timer start fail ret=%d -->\r\n",ret);		#endif        return;    }	//else{APP_DEBUG("<-- Watchdog Timer Start\r\n");}		// #if APP_DEBUG_ENABLE    // APP_DEBUG("<-- Watchdog Timer start OK  ret=%d-->\r\n",ret);	// #endif}void WTD_DeInit(){	#if APP_DEBUG_ENABLE    APP_DEBUG("<-- Watchdog Timer DeInit -->\r\n");	#endif	Ql_Timer_Stop(TIMER_ID_WATCHDOG_FEED);}void CAPTURE_DATA_FOR_PAYLOAD(char *Data_Buf, int Lenght_Param, char Data_Type){	u32 INTEGER_VAR = 0;	float FLOAT_DATA_OF_METER=0.0;	u8 i=0;	u8 Temp_Buff[1024];		Ql_memset(Temp_Buff, 0x00, sizeof(Temp_Buff));		if((Lenght_Param % 2) == 0)	{	//	APP_DEBUG("<-- LENGTH IS EVEN\r\n");	}	else	{	//	APP_DEBUG("<-- LENGTH IS ODD\r\n");		Lenght_Param = Lenght_Param + 1;	}		if(Data_Type == NORMAL_DATA)	{		for(i=0; i<(Lenght_Param/2); i++)		{			INTEGER_VAR = HEX_TO_INTEGER(*Data_Buf, *(Data_Buf+1));			Ql_sprintf(Temp_Buff,"%s%05d,\0",Temp_Buff,INTEGER_VAR);			Data_Buf = Data_Buf + 2;						// FLOAT_DATA_OF_METER = HEX_TO_FLOAT(*Data_Buf, *(Data_Buf+1), *(Data_Buf+2), *(Data_Buf+3));			// Ql_sprintf(Temp_Buff,"%s%07.2f,\0",Temp_Buff,FLOAT_DATA_OF_METER);			// Data_Buf = Data_Buf + 4;			NO_OF_MODBUS_VARIABLE_COUNT++;		}	}	else if(Data_Type == ERROR_DATA)	{		for(i=0; i<(Lenght_Param/2); i++)		{			//INTEGER_VAR = HEX_TO_INTEGER(*Data_Buf, *(Data_Buf+1));			//Ql_sprintf(Temp_Buff,"%s%05d,\0",Temp_Buff,INTEGER_VAR);			//Data_Buf = Data_Buf + 2;			Ql_sprintf(Temp_Buff,"%s00000,\0",Temp_Buff);			// FLOAT_DATA_OF_METER = HEX_TO_FLOAT(*Data_Buf, *(Data_Buf+1), *(Data_Buf+2), *(Data_Buf+3));			// Ql_sprintf(Temp_Buff,"%s%07.2f,\0",Temp_Buff,FLOAT_DATA_OF_METER);			// Data_Buf = Data_Buf + 4;			NO_OF_MODBUS_VARIABLE_COUNT++;		}	}	else if(Data_Type == NO_COMM_DATA)	{		for(i=0; i<(Lenght_Param/2); i++)		{			Ql_sprintf(Temp_Buff,"%s00000,\0",Temp_Buff);			NO_OF_MODBUS_VARIABLE_COUNT++;		}	}	else{APP_DEBUG("<-- WRONG TYPE IS RCV FOR PAYLOAD PROCESS\r\n");}		APP_DEBUG("<-- Response_Buff = %s\r\n", Temp_Buff);		// if(Flag==1)	// {		// strcat(Temp_Buff,":,");		// Flag=0;	// }		Ql_sprintf(DATA_FROM_CONTROLLER,"%s%s\0",DATA_FROM_CONTROLLER, Temp_Buff);	//APP_DEBUG("<-- DATA_FROM_CONTROLLER = %s\r\n", DATA_FROM_CONTROLLER);	APP_DEBUG("<-- NO_OF_MODBUS_VARIABLE_COUNT = %d\r\n\r\n", NO_OF_MODBUS_VARIABLE_COUNT);} void PAYLOAD_FORMATION_FOR_SENDING(char PACKET_TYPE){	u16 Data_Packet_Length;	u8 START_OF_THE_STRING[20] = "*\0", END_OF_THE_REQUEST_STRING = ':';	u8 START_OF_THE_MESSAGE[80];	u8 DATA_STRING[6] = "DATA\0", COMMUNICATION_ERROR[6] = "CEWC\0", COMMUNICATION_ERR_PORT2[6] = "CEC1\0", COMMUNICATION_ERR_PORT3[6] = "CEC2\0"; 	u8 SLAVE_ID_START = 1, SLAVE_ID_END = 3;	    Ql_memset(HTTP_POST_MSG,0,sizeof(HTTP_POST_MSG));	Ql_memset(START_OF_THE_MESSAGE,0,sizeof(START_OF_THE_MESSAGE));		Ql_sprintf(START_OF_THE_MESSAGE,"%s,%s,%s,%s,%s,%08.5f,%08.5f\0",START_OF_THE_STRING, DEVICE_ID, MODEL_NAME, UTC_DATE_TIME, VERSION, DEVICE_LATITUDE, DEVICE_LONGITUDE);		if(DATA_PACKET == PACKET_TYPE)	{		//Ql_sprintf(HTTP_POST_MSG, "%s,%03d,%s,%02d,%02d%c%s>%s^%s>%s^%s>%s^%s>%s^%s>%s#\0",START_OF_THE_MESSAGE, ERROR_STATUS_1, DATA_STRING, SLAVE_ID_START, SLAVE_ID_END, END_OF_THE_REQUEST_STRING, UTC_DATE_TIME_1, DATA_FROM_CONTROLLER, UTC_DATE_TIME_2, DATA_FROM_CONTROLLER_2, UTC_DATE_TIME_3, DATA_FROM_CONTROLLER_3, UTC_DATE_TIME_4, DATA_FROM_CONTROLLER_4, UTC_DATE_TIME_5, DATA_FROM_CONTROLLER_5);				Ql_sprintf(HTTP_POST_MSG, "%s,%03d,%s,%02d,%02d,%c,%s#\0",START_OF_THE_MESSAGE, ERROR_STATUS_1, DATA_STRING, SLAVE_ID_START, SLAVE_ID_END, END_OF_THE_REQUEST_STRING, DATA_FROM_CONTROLLER);				Data_Packet_Length = strlen(HTTP_POST_MSG);		STORE_DATA_LENGTH = Data_Packet_Length;	}	else if(PACKET_TYPE == NO_COMM_WITH_CONTROLLER_PACKET) 	{		comm_flag = 0;		//Ql_sprintf(HTTP_POST_MSG, "%s,%03d,%s,%02d,%02d%c%s>%s^%s>%s^%s>%s^%s>%s^%s>%s#\0",START_OF_THE_MESSAGE, ERROR_STATUS_1, COMMUNICATION_ERROR, SLAVE_ID_START, SLAVE_ID_END, END_OF_THE_REQUEST_STRING, UTC_DATE_TIME_1, DATA_FROM_CONTROLLER, UTC_DATE_TIME_2, DATA_FROM_CONTROLLER_2, UTC_DATE_TIME_3, DATA_FROM_CONTROLLER_3, UTC_DATE_TIME_4, DATA_FROM_CONTROLLER_4, UTC_DATE_TIME_5, DATA_FROM_CONTROLLER_5);				Ql_sprintf(HTTP_POST_MSG, "%s,%03d,%s,%02d,%02d,%c,%s#\0",START_OF_THE_MESSAGE, ERROR_STATUS_1, COMMUNICATION_ERROR, SLAVE_ID_START, SLAVE_ID_END, END_OF_THE_REQUEST_STRING, DATA_FROM_CONTROLLER);				Data_Packet_Length = strlen(HTTP_POST_MSG);		STORE_DATA_LENGTH = Data_Packet_Length;	}			APP_DEBUG("<-- Data_Packet_Length = %d\r\n",Data_Packet_Length);}void SendEvent2SubTask(u32 msgId,u32 iData1, u32 iData2){    int iTmp = 0;    int iRet = 0;    	// iTmp = subtask1_id;		// iRet = Ql_OS_SendMessage(iTmp,msgId,iData1, iData2);		// #if 1      		// if(iRet <0)		// {		// APP_DEBUG("<--failed!!,Ql_OS_SendMessage(%d,%d,%d,%d) fail, ret=%d-->\r\n", iTmp,msgId,iData1, iData2, iRet); 		// }		// APP_DEBUG("<--Ql_OS_SendMessage(%d, %d, %d, %d)=%d-->\r\n", iTmp,msgId,iData1, iData2, iRet);	// #endif		//s_iPassTask = subtask1_id;	s_iPassTask = 0;	iRet = Ql_OS_SendMessage(s_iPassTask,MSG_ID_USER_DATA,iData1, iData2);	if(iRet <0)	{		APP_DEBUG("\r\n<--failed!!, Ql_OS_SendMessage(1, %d, %d) fail,  ret=%d-->\r\n", iData1, iData2, iRet);	}//	APP_DEBUG("\r\n<--Ql_OS_SendMessage(%d, %d, %d) ret=%d-->\r\n",MSG_ID_USER_DATA,iData1, iData2, iRet);}float HEX_TO_FLOAT(unsigned char Value_3 ,unsigned char Value_4,unsigned char Value_1,unsigned char Value_2){	u64 calculated_dec_val =0;	u32 temp_var, temp_var3, temp_var4;	int temp_var1, temp_var2;	float temp_var5;	float result_cal=0;	bool sign_flag =0 ;		//APP_DEBUG("\r\n Value_1 = %d, Value_2 = %d, Value_3 = %d, Value_4 = %d", Value_1, Value_2, Value_3, Value_4);		calculated_dec_val = ((Value_1 * 256 * 256 * 256) + (Value_2 * 256 * 256) + (Value_3 * 256 ) + Value_4);	//APP_DEBUG("\r\n calculated dec val = %d \r\n", calculated_dec_val);		if(2147483648 > calculated_dec_val) // Sign 0 = 1 Calculation	{		temp_var = calculated_dec_val;	}	else                    // Sign 1 = -1 Calculation	{		temp_var = calculated_dec_val - 2147483648;		sign_flag = 1;	}		temp_var1 = floor(temp_var / pow(2,23));	temp_var2 = (temp_var1 - 127); // Exponent Value		temp_var3 = (temp_var1 * pow(2,23));		temp_var4 = (temp_var - temp_var3 );		//APP_DEBUG("\r\n 2nd temp var = %d , temp var1 = %d , temp var2 = %d , temp va3r = %d , temp var4 = %d \r\n", temp_var, temp_var1, temp_var2, temp_var3, temp_var4);		if(temp_var2 == 0) // Check If Exponent Value Zero	{		temp_var5 = (float)(temp_var4 / 4194304.0); // Mantissa Value	}	else // Check If Exponent Value Non Zero	{		temp_var5 = ((float)(temp_var4 / 8388608.0) + 1); // Mantissa Value	}		//APP_DEBUG("\r\n temp_var5 = %f \r\n", temp_var5);		if(sign_flag == 0)	{		result_cal = (1 * temp_var5 * pow(2,temp_var2)); // FLOAT = SIGN x MANTISSA x (2 ^ EXPONENT)	}	else	{		result_cal = (-1 * temp_var5 * pow(2,temp_var2)); // FLOAT = SIGN x MANTISSA x (2 ^ EXPONENT)	}	APP_DEBUG("\r\n result_cal = %f \r\n", result_cal);		//if(result_cal == inf)	//{		//APP_DEBUG("\r\n result_cal is infinity\r\n");	//	return(0);	//} 	return(result_cal);	}u32 HEX_TO_INTEGER(char Hex_Value_1, char Hex_Value_2){	u32 Integer_Data=0;		Integer_Data = (Hex_Value_1 * 256) + Hex_Value_2;		return Integer_Data;}s32 UNSIGNED_TO_SIGNED(u32 Integer_Value){	s32 calculated_value=0;		if(Integer_Value > 32767)	{		calculated_value = 65536 - Integer_Value;		calculated_value = calculated_value * -1;	}	else	{		calculated_value = Integer_Value;	}		return calculated_value;}void CREATE_AND_SEND_MODBUS_DATA(char Device_ID, char Function_Code, int Modbus_Address, int Data_To_Write_Or_Lenght){    unsigned short int crc16;	unsigned char ch_byte_cntr,ch_bit_cntr,chcarry,ch_crc,tx1buf[8]={0};	char i;//	APP_DEBUG("<-- CRC CALCULATION FUNCTION\r\n");		 	//APP_DEBUG("\r\n<-- SLAVE ID:%d, Function_Code: %d, Modbus_Address: %d, Length: %d -->\r\n",Device_ID, Function_Code, Modbus_Address, Data_To_Write_Or_Lenght);	if(Modbus_Address > 0)	{		Modbus_Address = Modbus_Address - 1;	}		tx1buf[0]= Device_ID;	tx1buf[1]= Function_Code;	tx1buf[2]= Modbus_Address / 256; 	tx1buf[3]= Modbus_Address % 256; 	tx1buf[4]= Data_To_Write_Or_Lenght/256; 	tx1buf[5]= Data_To_Write_Or_Lenght%256; 		crc16 = 0xffff;	for(ch_byte_cntr = 0; ch_byte_cntr < 6; ch_byte_cntr++)	{		ch_crc = tx1buf[ch_byte_cntr];		crc16 = crc16 ^ ch_crc;		for(ch_bit_cntr = 0; ch_bit_cntr < 8; ch_bit_cntr++)		{			chcarry = crc16 & 0x0001;			crc16 = crc16 >> 1;			if(chcarry)			{				crc16 = (crc16 ^ 0xA001);			}		}	}		ch_crc = crc16 & 0xff;	tx1buf[6] = ch_crc;	//APP_DEBUG("\r\ch_crc1 = %d string = %s\r\n", ch_crc, tx1buf);  		crc16 = crc16 >> 8;	ch_crc = crc16 & 0xff;	tx1buf[7] = ch_crc;	//APP_DEBUG("\r\ch_crc2 = %d string = %s\r\n", ch_crc, tx1buf);  //	APP_DEBUG("<-- MODBUS QUERY FOR WRITE\r\n\n");		for(i = 0; i<8; i++)	{		APP_DEBUG("%c%c  ",DECIMAL_TO_HEX(tx1buf[i] / 0x10),DECIMAL_TO_HEX(tx1buf[i] % 0x10));	}//	APP_DEBUG("\n");	Ql_UART_Write(UART_PORT2, tx1buf, 8 );	CHECK_MODBUS_QUERY_RESPONSE_FLAG = 1;//	APP_DEBUG("<-- MODBUS WRITE QUERY SEND ON UART PORT2\n\r");}void CALCULATE_CRC(int address_1, int data_1){    unsigned short int crc16;	unsigned char ch_byte_cntr,ch_bit_cntr,chcarry,ch_crc,tx1buf[8]={0};	char i;//	APP_DEBUG("<-- CRC CALCULATION FUNCTION\r\n");		 	//address_1 = address_1 - 1;             // address adustment for modbus protocol	tx1buf[0]= 0x01; 	if(address_1 >= 10000)	{		address_1 = address_1 - 10000;		tx1buf[1]= 0x05; 	} 	else	{		tx1buf[1]= 0x06; 	}	tx1buf[2]= address_1 / 256; 	tx1buf[3]= address_1 % 256; 	tx1buf[4]= data_1/256; 	tx1buf[5]= data_1%256; 		crc16 = 0xffff;	for(ch_byte_cntr = 0; ch_byte_cntr < 6; ch_byte_cntr++)	{		ch_crc = tx1buf[ch_byte_cntr];		crc16 = crc16 ^ ch_crc;		for(ch_bit_cntr = 0; ch_bit_cntr < 8; ch_bit_cntr++)		{			chcarry = crc16 & 0x0001;			crc16 = crc16 >> 1;			if(chcarry)			{				crc16 = (crc16 ^ 0xA001);			}		}	}		ch_crc = crc16 & 0xff;	tx1buf[6] = ch_crc;	//APP_DEBUG("\r\ch_crc1 = %d string = %s\r\n", ch_crc, tx1buf);  		crc16 = crc16 >> 8;	ch_crc = crc16 & 0xff;	tx1buf[7] = ch_crc;	//APP_DEBUG("\r\ch_crc2 = %d string = %s\r\n", ch_crc, tx1buf);  //	APP_DEBUG("<-- MODBUS QUERY FOR WRITE\r\n\n");		for(i = 0; i<8; i++)	{		APP_DEBUG("%c%c  ",DECIMAL_TO_HEX(tx1buf[i] / 0x10),DECIMAL_TO_HEX(tx1buf[i] % 0x10));	}	APP_DEBUG("\n");	Ql_UART_Write(UART_PORT2, tx1buf, 8 );//	APP_DEBUG("<-- MODBUS WRITE QUERY SEND ON UART PORT2\n\r"); }  static u8 MODBUS_CRC16_CHECK(u8 *buf, u32 len){	u16 crc = 0xFFFF;	u32 i, pos;	u16 ResCRC;			for(pos = 0; pos < len; pos++)	{		crc ^= (u8)buf[pos];    		// XOR byte into least sig. byte of crc		for (i = 8; i != 0; i--)		{    							// Loop over each bit			if ((crc & 0x0001) != 0)			{      						// If the LSB is set				crc >>= 1;              // Shift right and XOR 0xA001				crc ^= 0xA001;			}			else                        // Else LSB is not set				crc >>= 1;              // Just shift right		}	}		eat_trace("<-- CRC_CALCULATED = %x\r\n", crc); 		((char *) &ResCRC)[0] = buf[pos];	((char *) &ResCRC)[1] = buf[pos+1];		if(crc != ResCRC)	{		//eat_trace("\r\n<-- RESPONSE VALIDATION FAIL!\r\n\n");		return 0;	}	else{//eat_trace("\r\n<-- RESPONSE VALIDATION SUCCESS\r\n\n");	return 1;}}void DELAY(int time_delay){	int k,l;	for(k=0;k<time_delay;k++)	{		for(l=0;l<1024;l++)		{}	}	APP_DEBUG("<-- DELAY OVER\r\n");}char DECIMAL_TO_HEX(unsigned n){    if (n < 10) {        return n + '0';    } else {        return (n - 10) + 'A';    }}#endif // __EXAMPLE_TRANSPASS___